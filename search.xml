<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>List集合,Set集合,Collections工具类</title>
      <link href="/2019/09/16/list-ji-he-set-ji-he-collections-gong-ju-lei/"/>
      <url>/2019/09/16/list-ji-he-set-ji-he-collections-gong-ju-lei/</url>
      
        <content type="html"><![CDATA[<h3 id="1-List接口"><a href="#1-List接口" class="headerlink" title="1 List接口"></a>1 List接口</h3><h4 id="1-1-List介绍"><a href="#1-1-List介绍" class="headerlink" title="1.1 List介绍"></a>1.1 List介绍</h4><p>特点:            </p><ol><li>List元素有序</li><li>List带索引</li><li>集合中可以有重复元素,通过元素的equals方法来比较是否为重复元素</li></ol><h4 id="1-2-List常用方法"><a href="#1-2-List常用方法" class="headerlink" title="1.2 List常用方法"></a>1.2 List常用方法</h4><ul><li><code>public void add(int index, E element)</code>: 将指定的元素，添加到该集合中的指定位置上。</li><li><code>public E get(int index)</code>:返回集合中指定位置的元素。</li><li><code>public E remove(int index)</code>: 移除列表中指定位置的元素, 返回的是被移除的元素。</li><li><code>public E set(int index, E element)</code>:用指定元素替换集合中指定位置的元素,返回值的更新前的元素。</li></ul><h4 id="1-3-ArrayList集合"><a href="#1-3-ArrayList集合" class="headerlink" title="1.3 ArrayList集合"></a>1.3 ArrayList集合</h4><p><code>java.util.ArrayList</code><br>特点:<br>增删慢,查询快,存储结构为数组结构</p><h4 id="1-4-LinkedList集合"><a href="#1-4-LinkedList集合" class="headerlink" title="1.4 LinkedList集合"></a>1.4 LinkedList集合</h4><p><code>java.util.LinkedList</code><br>特点:<br>增删快,存储结构为双向链表<br><img src="https://ws1.sinaimg.cn/mw690/006lnyTwly1g71mjv6uafj30jo08rt8r.jpg" alt></p><h5 id="1-4-1-常用方法"><a href="#1-4-1-常用方法" class="headerlink" title="1.4.1 常用方法"></a>1.4.1 常用方法</h5><ul><li><code>public void addFirst(E e)</code>:将指定元素插入此列表的开头。</li><li><code>public void addLast(E e)</code>:将指定元素添加到此列表的结尾。</li><li><code>public E getFirst()</code>:返回此列表的第一个元素。</li><li><code>public E getLast()</code>:返回此列表的最后一个元素。</li><li><code>public E removeFirst()</code>:移除并返回此列表的第一个元素。</li><li><code>public E removeLast()</code>:移除并返回此列表的最后一个元素。</li><li><code>public E pop()</code>:从此列表所表示的堆栈处弹出一个元素。</li><li><code>public void push(E e)</code>:将元素推入此列表所表示的堆栈。</li><li><code>public boolean isEmpty()</code>：如果列表不包含元素，则返回true。</li></ul><h3 id="2-Set接口"><a href="#2-Set接口" class="headerlink" title="2 Set接口"></a>2 Set接口</h3><p>特点: </p><ol><li>元素不重复</li><li>没有索引也不能用for循环遍历,与Collection类似.</li></ol><h4 id="2-1-HashSet集合介绍"><a href="#2-1-HashSet集合介绍" class="headerlink" title="2.1 HashSet集合介绍"></a>2.1 HashSet集合介绍</h4><p><code>java.util.HashSet</code><br>特点:  </p><ol><li>哈希表结构速度快</li><li>是一个无序集合,存储元素和取出元素的顺序可能不一样.</li></ol><p>哈希值:  是一个十进制的整数,由系统随机给出(就是对象的地址值,是一个逻辑地址,是模拟出来得到地址,不是数据实际存储的物理地址)<br>在Object类有一个方法,可以获取对象的哈希吗值</p><pre><code>public native  int hashCode()//native代表该方法调用的是本地操作系统的方法</code></pre><p><img src="https://ws1.sinaimg.cn/mw690/006lnyTwly1g71ng9r5bqj30wf0famyf.jpg" alt></p><h4 id="2-2-HashSet集合存储数据的结构"><a href="#2-2-HashSet集合存储数据的结构" class="headerlink" title="2.2 HashSet集合存储数据的结构"></a>2.2 HashSet集合存储数据的结构</h4><p>哈希表是由数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的           </p><p><img src="https://ws1.sinaimg.cn/mw690/006lnyTwly1g71nga051uj30pi0p4q5i.jpg" alt><br>存储流程图    </p><pre><code>JDK1.8引入红黑树大程度优化了HashMap的性能，那么对于我们来讲保证HashSet集合元素的唯一，其实就是根据对象的hashCode和equals方法来决定的。如果我们往集合中存放自定义的对象，那么保证其唯一，就必须复写hashCode和equals方法建立属于当前对象的比较方式。</code></pre><h4 id="2-3-LinkedHashSet"><a href="#2-3-LinkedHashSet" class="headerlink" title="2.3 LinkedHashSet"></a>2.3 LinkedHashSet</h4><p>在HashSet下面有一个子类<code>java.util.LinkedHashSet</code>，它是链表和哈希表组合的一个数据存储结构。</p><h4 id="2-4-可变参数"><a href="#2-4-可变参数" class="headerlink" title="2.4 可变参数"></a>2.4 可变参数</h4><p>使用前提:<br>当方法的参数列表数据类型已经确定,但是参数的个数不确定,就可以使用可变参数.<br>使用格式:定义方法时使用<br>    <code>修饰符 返回值类型 方法名(数据类型...变量名){}</code><br>可变参数原理:<br>可变参数底层是一个数组,根据传递参数个数不同,会创建不同长度的数组,来存储这些参数,传递参数的个数可以是0个到多个</p><h3 id="3-Collections-类"><a href="#3-Collections-类" class="headerlink" title="3 Collections 类"></a>3 Collections 类</h3><h4 id="3-1-常用方法"><a href="#3-1-常用方法" class="headerlink" title="3.1 常用方法"></a>3.1 常用方法</h4><ul><li><p>java.utils.Collections`是集合工具类，用来对集合进行操作。部分方法如下：</p></li><li><p><code>public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements)</code>:往集合中添加一些元素。</p></li><li><p><code>public static void shuffle(List&lt;?&gt; list) 打乱顺序</code>:打乱集合顺序。</p></li><li><p><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>:将集合中元素按照默认规则排序。</p></li><li><p><code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code>:将集合中元素按照指定规则排序。</p></li></ul><p>注意:<br>sort方法的使用前提 被排序的集合里边存储的元素,必须实现Comparable,重写接口中的方法CompareTo</p><p>排序规则 自己-参数 升序</p><h4 id="3-2-Comparator比较器"><a href="#3-2-Comparator比较器" class="headerlink" title="3.2 Comparator比较器"></a>3.2 Comparator比较器</h4><p>public int compare(String o1, String o2)`：比较其两个参数的顺序。</p><blockquote><p>两个对象比较的结果有三种：大于，等于，小于。</p><p>如果要按照升序排序，<br>则o1 小于o2，返回（负数），相等返回0，01大于02返回（正数）<br>如果要按照降序排序<br>则o1 小于o2，返回（正数），相等返回0，01大于02返回（负数）</p></blockquote><h4 id="3-3-Comparable和Comparator两个接口的区别"><a href="#3-3-Comparable和Comparator两个接口的区别" class="headerlink" title="3.3 Comparable和Comparator两个接口的区别"></a>3.3 Comparable和Comparator两个接口的区别</h4><p><strong>Comparable</strong>：强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的compareTo方法被称为它的自然比较方法。只能在类中实现compareTo()一次，不能经常修改类的代码实现自己想要的排序。实现此接口的对象列表（和数组）可以通过Collections.sort（和Arrays.sort）进行自动排序，对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。</p><p><strong>Comparator</strong>强行对某个对象进行整体排序。可以将Comparator 传递给sort方法（如Collections.sort或 Arrays.sort），从而允许在排序顺序上实现精确控制。还可以使用Comparator来控制某些数据结构（如有序set或有序映射）的顺序，或者为那些没有自然顺序的对象collection提供排序。</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> List集合 </tag>
            
            <tag> Set集合 </tag>
            
            <tag> Collections工具类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础语法（二）</title>
      <link href="/2019/09/16/java-ji-chu-er/"/>
      <url>/2019/09/16/java-ji-chu-er/</url>
      
        <content type="html"><![CDATA[<h3 id="1-封装性"><a href="#1-封装性" class="headerlink" title="1.封装性"></a>1.封装性</h3><h4 id="1-1-封装概念"><a href="#1-1-封装概念" class="headerlink" title="1.1 封装概念"></a>1.1 封装概念</h4><p>封装就是将一些细节信息隐藏起来，对于外界不可见。若需要访问某个属性，提供公共方法对其访问。   </p><h4 id="1-2-封装的步骤"><a href="#1-2-封装的步骤" class="headerlink" title="1.2 封装的步骤"></a>1.2 封装的步骤</h4><ol><li>使用private关键字来修饰成员变量。           </li><li>对需要访问的成员变量，提供对应的一对get方法丶set方法。    <h4 id="1-3-封装性在JAVA中的体现"><a href="#1-3-封装性在JAVA中的体现" class="headerlink" title="1.3 封装性在JAVA中的体现"></a>1.3 封装性在JAVA中的体现</h4></li><li>方法就是一种封装            </li><li>关键字private也是一种封装        <h4 id="1-4-private关键字"><a href="#1-4-private关键字" class="headerlink" title="1.4 private关键字"></a>1.4 private关键字</h4></li><li>private是一个权限修饰符，代表最小权限。</li><li>可以修饰成员变量和成员方法。</li><li>被private修饰后的成员变量和成员方法，只在本类中才能访问。           <h4 id="1-5-this关键字"><a href="#1-5-this关键字" class="headerlink" title="1.5 this关键字"></a>1.5 this关键字</h4></li><li>当方法的局部变量和类的成员变量重名时，根据就近原则优先使用局部变量。</li><li>当需要访问成员变量时需要使用this关键字</li><li>通过谁调用的方法谁就是this</li><li>this在重名的情况下起到区分的效果</li></ol><h4 id="1-6-构造方法"><a href="#1-6-构造方法" class="headerlink" title="1.6 构造方法"></a>1.6 构造方法</h4><p>构造方法是专门用来创建对象的方法，当我们通过关键字new来创建对象，其实就是在调用构造方法<br>格式：</p><pre><code>public 类名称（参数类型 参数名称）｛方法体｝</code></pre><p>注意事项：</p><ol><li>构造方法的名称必须和所在的类名完全一样。</li><li>构造方法没有返回值。</li><li>若没有构造方法，编译器会默认赠送一个构造方法。</li></ol><h3 id="2-继承性"><a href="#2-继承性" class="headerlink" title="2.继承性"></a>2.继承性</h3><p>继承是多态的前提没有继承就没有多态<br>继承主要解决的问题就是：共性抽取<br>定义格式：          </p><pre><code>public class 父类 {}public class 子类 extends 父类 {}</code></pre><h4 id="2-1-nbsp-成员变量重名"><a href="#2-1-nbsp-成员变量重名" class="headerlink" title="2.1&nbsp;成员变量重名"></a>2.1&nbsp;成员变量重名</h4><p>直接通过子类对象访问成员变量;<br>    等号左边是谁，就优先用谁，没有则向上找。<br>间接通过成员方法访问成员变量<br>    该方法属于谁，就优先用谁，没有则向上找。              </p><h4 id="2-2-nbsp-super关键字"><a href="#2-2-nbsp-super关键字" class="headerlink" title="2.2&nbsp;super关键字"></a>2.2&nbsp;super关键字</h4><p>三种用法<br>1.在子类的成员方法中，访问父类的成员变量。<br>2.在子类的成员方法中，访问父类的成员方法。<br>3.在子类的构造方法中，访问父类的构造方法。</p><table><thead><tr><th>局部变量</th><th>直接写</th></tr></thead><tbody><tr><td>本类的成员变量</td><td>this.成员变量名</td></tr><tr><td>父类成员变量</td><td>super.成员变量名</td></tr></tbody></table><h4 id="2-3-nbsp-重写"><a href="#2-3-nbsp-重写" class="headerlink" title="2.3&nbsp;重写"></a>2.3&nbsp;重写</h4><p>子类继承父类时 子类重写父类的方法 方法名称一样参数列表也一样<br><strong>注意事项</strong>：             </p><ol><li>用@Override来检测是不是有效的覆盖重写</li><li>子类方法的返回值必须小于等于父类方法的返回值范围。</li><li>子类方法的权限必须大于等于父类方法的权限修饰符。</li></ol><h4 id="2-4-nbsp-继承中构造方法的访问特点"><a href="#2-4-nbsp-继承中构造方法的访问特点" class="headerlink" title="2.4&nbsp;继承中构造方法的访问特点"></a>2.4&nbsp;继承中构造方法的访问特点</h4><ol><li>子类必须调用父类的构造方法。</li><li>子类构造方法当中有一个默认隐含的“super()”调用，一定先调用父类构造，再执行子类构造。</li><li>子类构造可以通过super关键字调用父类重载构造。</li><li>不能一个子类构造调用多次super构造。               </li></ol><p><strong>总结</strong>：子类必须调用父类的构造方法，不写则赠送super();<br>&emsp;&emsp;&emsp;写了则用写的指定的super调用，super只能有一个，还必须是第一个。</p><h4 id="2-5this关键字用法"><a href="#2-5this关键字用法" class="headerlink" title="2.5this关键字用法"></a>2.5this关键字用法</h4><ol><li>在本来的成员方法中，访问本类的成员变量。</li><li>在本类的成员方法中，访问本类的另一个成员方法。</li><li>在本类的构造方法中，访问本类的另一个构造方法。（A.注意this（…）调用也必须是构造方法的第一个语句，唯一一个。B.super和this两种构造，不能同时调用。）</li></ol><h4 id="2-6-nbsp-this与super的内存图"><a href="#2-6-nbsp-this与super的内存图" class="headerlink" title="2.6&nbsp;this与super的内存图"></a>2.6&nbsp;this与super的内存图</h4><p><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/03-super%E4%B8%8Ethis%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE.png" alt></p><h4 id="2-7-nbsp-继承的三个特点"><a href="#2-7-nbsp-继承的三个特点" class="headerlink" title="2.7&nbsp;继承的三个特点"></a>2.7&nbsp;继承的三个特点</h4><ol><li>单继承：一个类的直接父类只能有唯一一个。</li><li>多级继承：一个类的父类还可以有父类。</li><li>多子类：一个父类可以拥有很多子类。</li></ol><h3 id="3-多态性"><a href="#3-多态性" class="headerlink" title="3. 多态性"></a>3. 多态性</h3><h4 id="3-1-多态概念"><a href="#3-1-多态概念" class="headerlink" title="3.1 多态概念"></a>3.1 多态概念</h4><p>父类引用指向子类对象，就是对象的多样性。</p><pre><code>代码当中体现多态性，其实就是一句话，父类引用指向子类对象。格式：父类名称 对象名 = new 子类名称();或者:接口名称 对象名 = new 实现类名称();</code></pre><h4 id="3-2-多态中访问成员变量"><a href="#3-2-多态中访问成员变量" class="headerlink" title="3.2 多态中访问成员变量"></a>3.2 多态中访问成员变量</h4><ol><li>直接通过对象名称访问成员变量，看等号左边是谁，优先用谁，没有则向上找。         </li><li>间接通过成员方法访问成员变量，看方法属于谁，优先用谁，没有则向上找。</li></ol><h4 id="3-3-多态中访问成员方法"><a href="#3-3-多态中访问成员方法" class="headerlink" title="3.3 多态中访问成员方法"></a>3.3 多态中访问成员方法</h4><ol><li>看new的是谁，就优先用谁，没有则向上找。【编译看左边，运行看右边】</li></ol><h4 id="3-4-多态使用好处"><a href="#3-4-多态使用好处" class="headerlink" title="3.4 多态使用好处"></a>3.4 多态使用好处</h4><p>无论右边new的时候换成哪个子类对象，等号左边调用方法都不会变化。</p><h4 id="3-5-对象的上转型"><a href="#3-5-对象的上转型" class="headerlink" title="3.5 对象的上转型"></a>3.5 对象的上转型</h4><p>格式：父类名称 对象名 = new 子类名称();<br>含义：右侧创建一个子类对象，把它当做父类对象来使用。<br>注意事项：向上转型一定是安全的。从小范围转向了大范围。<br>对象一旦向上转型为父类，那么就无法调用子类原本特有的内容。</p><h4 id="3-6-对象的下转型"><a href="#3-6-对象的下转型" class="headerlink" title="3.6 对象的下转型"></a>3.6 对象的下转型</h4><p>其实是一个【还原】的动作<br>格式 子类对象名称 对象名 = (子类名称)父类对象;<br>概念：将父类对象还原成为本来的子类对象。</p><h4 id="3-7-instanceof判断类型"><a href="#3-7-instanceof判断类型" class="headerlink" title="3.7 instanceof判断类型"></a>3.7 instanceof判断类型</h4><p>格式：<br>对象 instanceof 类名称<br>这将会得到一个boolean值结果，也就是判断前面的对象能不能当做后面类型的实例。</p><h3 id="4-抽象类"><a href="#4-抽象类" class="headerlink" title="4. 抽象类"></a>4. 抽象类</h3><h4 id="4-1-抽象方法"><a href="#4-1-抽象方法" class="headerlink" title="4.1 抽象方法"></a>4.1 抽象方法</h4><p>如果父类中的方法不确定如何让进行方法体的实现，那么这个方法就是抽象方法，动物吃东西，图形算面积。</p><h4 id="4-2-抽象类"><a href="#4-2-抽象类" class="headerlink" title="4.2 抽象类"></a>4.2 抽象类</h4><p>抽象方法所在的类就是抽象类。</p><h4 id="4-3-抽象方法写法"><a href="#4-3-抽象方法写法" class="headerlink" title="4.3 抽象方法写法"></a>4.3 抽象方法写法</h4><p>方法前加上abstract关键字去掉大括号 </p><h4 id="4-4-如何使用抽象类和抽象方法"><a href="#4-4-如何使用抽象类和抽象方法" class="headerlink" title="4.4 如何使用抽象类和抽象方法"></a>4.4 如何使用抽象类和抽象方法</h4><ol><li>不能直接创建抽象类对象。</li><li>必须用一个子类来继承父类。</li><li>子类必须重写抽象父类当中所有的抽象方法。</li><li>创建子类对象进行使用。</li></ol><h4 id="4-5-注意事项"><a href="#4-5-注意事项" class="headerlink" title="4.5 注意事项"></a>4.5 注意事项</h4><ol><li>抽象类不能创建对象，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。</li><li>抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。</li><li>抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</li><li>抽象类的子类，必须重写抽象父类中所有的抽象方法，否则，编译无法通过而报错。除非该子类也是抽象类。</li></ol><h3 id="5-接口"><a href="#5-接口" class="headerlink" title="5. 接口"></a>5. 接口</h3><h4 id="5-1-概念"><a href="#5-1-概念" class="headerlink" title="5.1 概念"></a>5.1 概念</h4><p>接口就是一种公共的规范标准。<br>接口就是多个类的公共规范。<br>接口是一种引用数据类型，最重要的内容就是其中的抽象方法        </p><pre><code>接口定义           public interface 接口名称{       //接口内容        }</code></pre><pre><code>接口中抽象方法定义public abstract 返回值类型 方法名称(参数列表);</code></pre><p>注意：public abstract 是固定写法 可以省略；<br>备注：换成了关键字interface之后,编译生成的字节码文件仍然是；.java –&gt; .class         </p><h4 id="5-2-接口中的内容"><a href="#5-2-接口中的内容" class="headerlink" title="5.2 接口中的内容"></a>5.2 接口中的内容</h4><p>如果是 Java 7  那么接口中可以包含的内容有   </p><ol><li>常量</li><li>抽象方法          </li></ol><p>如果是 Java 8  那么接口中可以包含的内容有</p><ol start="3"><li>默认方法         </li><li>静态方法     </li></ol><p>如果是 Java 9  那么接口中可以包含的内容有</p><ol start="5"><li>私有方法     </li></ol><p>默认方法<br>使用默认方法，如果实现类里面没有，会向上找接口。</p><pre><code>从Java 8开始， 接口里允许定义默认方法  格式：      public defult 返回值类型 方法名称(参数列表){    方法体}</code></pre><p>静态方法<br>通过接口名称直接调用静态方法。<br>不能通过接口实现类的对象来调用接口中的静态方法。</p><pre><code>从Java 8开始， 接口里允许定义静态方法  格式：      public static 返回值类型 方法名称(参数列表){    方法体}</code></pre><p>私有方法</p><ol><li>普通私有方法，解决多个默认方法之间重复代码问题。</li></ol><pre><code>格式：private 返回值类型 方法名称(参数列表){    方法体}</code></pre><ol start="2"><li>静态私有方法，解决多个精要方法之间重复代码问题。<pre><code>格式：private static  返回值类型 方法名称(参数列表){ 方法体}</code></pre></li></ol><pre><code>格式：private 返回值类型 方法名称(参数列表){    方法体}</code></pre><h4 id="5-3-接口使用步骤"><a href="#5-3-接口使用步骤" class="headerlink" title="5.3 接口使用步骤"></a>5.3 接口使用步骤</h4><ol><li>接口不能直接使用，必须有一个实现类来实现该接口。</li></ol><pre><code>格式：public class 实现类名称 implements 接口名称 ｛｝</code></pre><ol start="2"><li>接口的实现类必须重写（实现）接口中所有的抽象方法。<br>实现：去掉avstract关键字，加上方法体大括号。</li><li>创建实现类的对象，进行使用。</li></ol><p>注意事项：<br>如果实现类并没有覆盖重写接口中所有的抽象方法，那么这个实现类自己就必须是抽象类。</p><h4 id="5-4-接口定义“成员变量”"><a href="#5-4-接口定义“成员变量”" class="headerlink" title="5.4 接口定义“成员变量”"></a>5.4 接口定义“成员变量”</h4><p>接口中可以定义”成员变量”，但是必须使用 public static final 三个关键字进行修饰<br>从效果上看，这其实就是接口的【常量】。</p><pre><code>格式：public static final 数据类型 常量名称 = 数据值；</code></pre><p>注意：<br>一旦使用final关键字进行修饰，说明不可改变，<br>接口当中的常量，可以省略 public static final ；注意，不写也照样是这样。<br>接口中的常量必须进行赋值，不能不赋值。<br>接口中常量的名称使用完全大写的字母。用下划线进行分割。（推荐命名规则）                 </p><h4 id="5-5-接口注意事项"><a href="#5-5-接口注意事项" class="headerlink" title="5.5 接口注意事项"></a>5.5 接口注意事项</h4><ol><li>接口不能有静态代码块或者构造方法。</li><li>一个类的直接父类是唯一的，但是一个类可以同时实现多个接口。</li></ol><pre><code>格式： public class MyInterfaceImpl implements MyInterfaceA, MyInterfaceB {    //重写抽象方法}</code></pre><ol start="3"><li>如果实现类所实现的多个接口当中，存在重复的抽象方法，那么只需要重写一次即可。</li><li>如果实现类没有覆盖重写所有接口当中的所有抽象方法，那么实现类就是一个抽象类。</li><li>如果实现类实现的多个接口当中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写。</li><li>一个类如果直接父类当中的方法，和接口当中的默认方法产生了冲突，优先使用父类中的方法。</li></ol><h4 id="5-6-类与接口"><a href="#5-6-类与接口" class="headerlink" title="5.6 类与接口"></a>5.6 类与接口</h4><ol><li>类与类之间是单继承的。</li><li>类与接口之间是多实现的，一个类可以实现多个接口。</li><li>接口与接口之间是多继承的。<br>注意事项：</li><li>多个父接口中的默认方法重复。那么子接口必须进行默认方法的覆盖重写，【而且带着default关键字】</li></ol><h3 id="6-final关键字"><a href="#6-final关键字" class="headerlink" title="6. final关键字"></a>6. final关键字</h3><p>代表最终，不可改变的<br>常见的四种用法：</p><ol><li>可以修饰一个类</li><li>可以修饰一个方法</li><li>可以修饰一个局部变量</li><li>可以修饰一个成员变量</li></ol><h4 id="6-1-final修饰类"><a href="#6-1-final修饰类" class="headerlink" title="6.1 final修饰类"></a>6.1 final修饰类</h4><pre><code>当final关键字用来修饰一个类的时候public final class 类名称 {    //....}含义：当前这个类不能有任何子类(太监类)</code></pre><h4 id="6-2-final修饰方法"><a href="#6-2-final修饰方法" class="headerlink" title="6.2 final修饰方法"></a>6.2 final修饰方法</h4><pre><code>当final关键字用来修饰一个方法的时候，这个方法就是最终方法，也就是不能被覆盖重写。格式：修饰符 final 返回值类型 方法名称(参数列表) ｛    //方法体｝</code></pre><p>对于类丶方法来说abstract和final不能同时使用</p><h4 id="6-3-final修饰局部变量"><a href="#6-3-final修饰局部变量" class="headerlink" title="6.3 final修饰局部变量"></a>6.3 final修饰局部变量</h4><p>一旦使用final用来修饰局部变量，那么这个变量就不能进行更改。<br>    “一次赋值，终生不变”</p><pre><code>final int num;    num=3</code></pre><p>对于基本类型来说，不可变说的是变量当中的数据不可改变<br>对于引用类型来说，不可变说的是变量当中的地址值不可改变    </p><h4 id="6-4-final修饰成员变量"><a href="#6-4-final修饰成员变量" class="headerlink" title="6.4 final修饰成员变量"></a>6.4 final修饰成员变量</h4><p>对于成员变量来说，如果使用final关键字修饰，那么这个变量也照样是不可变。</p><ol><li>由于成员变量具有默认值，所以用了final之后必须手动赋值，不会再给默认值了。</li><li>对于fina的成员变量，要么使用直接赋值，要么通过构造方法赋值。 二者选其一。</li><li>必须保证类当中所有重载的构造方法，都最终会对final的成员变量进行赋值。</li></ol><h3 id="7-权限修饰符"><a href="#7-权限修饰符" class="headerlink" title="7. 权限修饰符"></a>7. 权限修饰符</h3><p>Java中有四种权限修饰符            </p><p>public &gt; protected &gt; (default) &gt; private                               </p><p>注意 :(default)并不是关键字“default”，而是根本不写。<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/JAVA2_03.png" alt></p><h3 id="8-内部类"><a href="#8-内部类" class="headerlink" title="8. 内部类"></a>8. 内部类</h3><p>8.1 概念<br>如果一个事物包含另一个事物，那么这就是一个类内部包含另一个类。<br>例如：人体和心脏的关系。<br>分类：</p><ol><li>成员内部类</li><li>局部内部类(包含匿名内部类)</li></ol><h4 id="8-2-成员内部类"><a href="#8-2-成员内部类" class="headerlink" title="8.2 成员内部类"></a>8.2 成员内部类</h4><p>成员内部类的定义格式</p><pre><code>修饰符 class 外部类名称 {    修饰符 class 内部类名称 {        //...    }    //...}</code></pre><p>注意：内用外，可以随意访问；外用内，需要内部类对象。</p><p>使用内部类的两种方式</p><ol><li>间接方式：在外部类的方法当中，使用内部类；然后main只是调用外部类的方法。</li><li>直接方式: 公式：外.内 </li></ol><pre><code>外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称();</code></pre><p>内部类和外部类并不是继承关系       </p><p>如果出现了重名情况</p><pre><code>Outer.this.成员变量名 //内部类方法中访问外部类成员变量</code></pre><h4 id="8-3-局部内部类"><a href="#8-3-局部内部类" class="headerlink" title="8.3 局部内部类"></a>8.3 局部内部类</h4><p>如果一个类是定义在一个方法内部的，那么这就是一个局部内部类。<br>“局部”：只有当前所属方法才能使用它，出了这个方法外面就不能用了。</p><pre><code>定义格式修饰符 class 外部类名称 {    修饰符 返回值类型 外部类方法名称(参数列表) {        class 局部内部类名称{        }    }}</code></pre><p>注意：局部内部类，如果希望访问所以在方法的局部变量，那么这个局部变量必须是【有效的final的】<br>备注：从Java 8+开始，只要局部变量事实不变，那么final关键字可以省略。</p><h4 id="8-4-权限修饰符规则"><a href="#8-4-权限修饰符规则" class="headerlink" title="8.4 权限修饰符规则"></a>8.4 权限修饰符规则</h4><ol><li>外部类：public / (default)</li><li>成员内部类：public / protected / (default) /private</li><li>局部内部类：什么都不能写</li></ol><h4 id="8-5-匿名内部类"><a href="#8-5-匿名内部类" class="headerlink" title="8.5 匿名内部类"></a>8.5 匿名内部类</h4><p>如果接口的实现类(或者是父类的子类)只需要使用唯一的一次。<br>那么这种情况就可以省略掉该类的定义，而改为使用【匿名内部类】。</p><pre><code>匿名内部类的定义格式：接口名称 对象名 = new 接口名称() {    //覆盖重写接口中所有抽象方法};</code></pre><p>注意事项：</p><ol><li>匿名内部类，在创建对象的时候，只能使用唯一的一次。</li><li>使用匿名内部类，但不是匿名对象，匿名内部类省略的是类名。</li></ol><p>类作为成员变量类型<br>接口也可以作为成员变量类型<br>成员变量可以用任何一种类</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 封装性 </tag>
            
            <tag> 继承 </tag>
            
            <tag> 多态 </tag>
            
            <tag> 接口 </tag>
            
            <tag> 抽象类 </tag>
            
            <tag> final关键字 </tag>
            
            <tag> 内部类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单的数据结构</title>
      <link href="/2019/09/16/jian-dan-de-shu-ju-jie-gou/"/>
      <url>/2019/09/16/jian-dan-de-shu-ju-jie-gou/</url>
      
        <content type="html"><![CDATA[<h2 id="简单的数据结构"><a href="#简单的数据结构" class="headerlink" title="简单的数据结构"></a>简单的数据结构</h2><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><ul><li><strong>栈</strong>：<strong>stack</strong>,又称堆栈，它是运算受限的线性表，其限制是仅允许在标的一端进行插入和删除操作，不允许在其他任何位置进行添加、查找、删除等操作。</li></ul><p>简单的说：采用该结构的集合，对元素的存取有如下的特点</p><ul><li><p>先进后出（即，存进去的元素，要在后它后面的元素依次取出后，才能取出该元素）。例如，子弹压进弹夹，先压进去的子弹在下面，后压进去的子弹在上面，当开枪时，先弹出上面的子弹，然后才能弹出下面的子弹。</p></li><li><p>栈的入口、出口的都是栈的顶端位置。</p></li></ul><p>这里两个名词需要注意：</p><ul><li><strong>压栈</strong>：就是存元素。即，把元素存储到栈的顶端位置，栈中已有元素依次向栈底方向移动一个位置。</li><li><strong>弹栈</strong>：就是取元素。即，把栈的顶端位置元素取出，栈中已有元素依次向栈顶方向移动一个位置。</li></ul><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><ul><li><strong>队列</strong>：<strong>queue</strong>,简称队，它同堆栈一样，也是一种运算受限的线性表，其限制是仅允许在表的一端进行插入，而在表的另一端进行删除。</li></ul><p>简单的说，采用该结构的集合，对元素的存取有如下的特点：</p><ul><li>先进先出（即，存进去的元素，要在后它前面的元素依次取出后，才能取出该元素）。例如，小火车过山洞，车头先进去，车尾后进去；车头先出来，车尾后出来。</li><li>队列的入口、出口各占一侧。例如，下图中的左侧为入口，右侧为出口。</li></ul><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><ul><li><strong>数组</strong>:<strong>Array</strong>,是有序的元素序列，数组是在内存中开辟一段连续的空间，并在此空间存放元素。就像是一排出租屋，有100个房间，从001到100每个房间都有固定编号，通过编号就可以快速找到租房子的人。</li></ul><p>简单的说,采用该结构的集合，对元素的存取有如下的特点：</p><ul><li>查找元素快：通过索引，可以快速访问指定位置的元素</li></ul><ul><li>增删元素慢<ul><li><strong>指定索引位置增加元素</strong>：需要创建一个新数组，将指定新元素存储在指定索引位置，再把原数组元素根据索引，复制到新数组对应索引的位置。如下图<img src="img/%E6%95%B0%E7%BB%84%E6%B7%BB%E5%8A%A0.png" alt></li><li><strong>指定索引位置删除元素：</strong>需要创建一个新数组，把原数组元素根据索引，复制到新数组对应索引的位置，原数组中指定索引位置元素不复制到新数组中.</li></ul></li></ul><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><ul><li><strong>链表</strong>:<strong>linked list</strong>,由一系列结点node（链表中每一个元素称为结点）组成，结点可以在运行时i动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。我们常说的链表结构有单向链表与双向链表，那么这里给大家介绍的是<strong>单向链表</strong>。</li></ul><p>简单的说，采用该结构的集合，对元素的存取有如下的特点：</p><ul><li>多个结点之间，通过地址进行连接。例如，多个人手拉手，每个人使用自己的右手拉住下个人的左手，依次类推，这样多个人就连在一起了。</li></ul><ul><li><p>查找元素慢：想查找某个元素，需要通过连接的节点，依次向后查找指定元素</p></li><li><p>增删元素快：</p><ul><li>增加元素：只需要修改连接下个元素的地址即可。</li></ul></li></ul><ul><li>删除元素：只需要修改连接下个元素的地址即可。</li></ul><h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><ul><li><strong>二叉树</strong>：<strong>binary tree</strong> ,是每个结点不超过2的有序<strong>树（tree）</strong> 。</li></ul><p>简单的理解，就是一种类似于我们生活中树的结构，只不过每个结点上都最多只能有两个子结点。</p><p>二叉树是每个节点最多有两个子树的树结构。顶上的叫根结点，两边被称作“左子树”和“右子树”。</p><p>我们要说的是二叉树的一种比较有意思的叫做<strong>红黑树</strong>，红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。</p><p>红黑树的约束:</p><ol><li>节点可以是红色的或者黑色的</li></ol><ol start="2"><li>根节点是黑色的</li></ol><ol start="3"><li>叶子节点(特指空节点)是黑色的</li><li>每个红色节点的子节点都是黑色的</li><li>任何一个节点到其每一个叶子节点的所有路径上黑色节点数相同</li></ol><p>红黑树的特点:</p><p>​    速度特别快,趋近平衡树,查找叶子元素最少和最多次数不多于二倍</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 栈 </tag>
            
            <tag> 队列 </tag>
            
            <tag> 红黑树 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Collection集合</title>
      <link href="/2019/09/15/collection-ji-he-yu-fan-xing/"/>
      <url>/2019/09/15/collection-ji-he-yu-fan-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Collection集合"><a href="#1-Collection集合" class="headerlink" title="1 Collection集合"></a>1 Collection集合</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><p>集合：集合是java中提空的一种容器，可以用来存储多个数据。<br>1.1.1集合与数组区别</p><ol><li>数组长度固定，集合长度可变</li><li>数组中存储的是同一类型的元素</li><li>数组可以存储基本数据类型和对象，集合只能存储对象。</li></ol><h3 id="1-2集合框架"><a href="#1-2集合框架" class="headerlink" title="1.2集合框架"></a>1.2集合框架</h3><p><img src="https://ws1.sinaimg.cn/mw690/006lnyTwly1g70omqzhpgj311w0lcad8.jpg" alt></p><h3 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h3><ol><li><p>有序的集合（存储和去除元素顺序相同）</p></li><li><p>允许存储重复元素</p></li><li><p>有索引，可以使用普通的for循环遍历</p><p>Vector集合 ArrayList集合 LinkedList集合 </p></li></ol><h3 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h3><ol><li><p>不允许存储重复元素</p></li><li><p>没有索引（不能使用普通的for循环遍历）</p><p>TreeSet集合 HashSet集合 LinkedHashSet集合</p><h3 id="Collection-接口"><a href="#Collection-接口" class="headerlink" title="Collection 接口"></a>Collection 接口</h3><p>定义的是所有单列集合共性的方法<br>所有的单列集合都可以使用的共性的方法(没有带索引的方法)            </p></li></ol><p><strong>java.util.Collection</strong>接口</p><p>所有单列集合的最顶层的接口，里面定义了所有单列集合的共性的方法 </p><p>任意的单列集合都可以使用Collection接口中的方法<br>共有的方法</p><ul><li>public boolean add(E e); 把给定的对象添加到当前集合中，</li><li>public boolean remove(E e);删除指定元素</li><li>public boolean contains();判断当前集合是否包含此对象</li><li>public boolean  isEmpty()//判断当前集合是否为空</li><li>public int size()//返回集合中元素个数</li><li>public Object[] toArray();//把集合中的元素，存储到数组当中。</li><li>public void clear();//清空集合中的所有元素</li></ul><h3 id="Iterator-迭代器"><a href="#Iterator-迭代器" class="headerlink" title="Iterator 迭代器"></a>Iterator 迭代器</h3><p>通用的遍历集合的方式</p><p>迭代：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，有，就把这个元素取出来，继续在判断，如果还有就再取出来。一直把集合中的元素全部取出。这种取出方式成为迭代。</p><p>常用方法<br><strong>public E next()</strong> 返回迭代下一个元素<br><strong>public boolean hasNext</strong> 判断是否有有下一个元素</p><h2 id="2-泛型"><a href="#2-泛型" class="headerlink" title="2 泛型"></a>2 泛型</h2><h3 id="2-1-泛型概述"><a href="#2-1-泛型概述" class="headerlink" title="2.1 泛型概述"></a>2.1 泛型概述</h3><p>集合中存储元素的类型称作泛型<br>泛型是一种未知的数据类型，当我们不知道使用什么数据类型的时侯，可以使用泛型。<br>泛型也可以看出是一个变量 用来接收数据类型      </p><p>常见的泛型：<br><strong>E e</strong>: Element 元素<br><strong>T t</strong>：Type 类型         </p><p>ArrayList集合在定义的时候不知道集合会存储什么数据，所以类型使用泛型<br>E ：未知的数据类型<br>会吧数据类型作为参数传递<br>创建集合对象的时候就会确定泛型的数据类型</p><h3 id="2-2-泛型好处"><a href="#2-2-泛型好处" class="headerlink" title="2.2 泛型好处"></a>2.2 泛型好处</h3><pre><code>当集合不使用用泛型时默认类型就是Object类型，可以存储任意类型的数据弊端。集合不安全，会引发异常。</code></pre><ol><li>避免了类型转换的麻烦，存储的是什么类型，取出的就是什么类型。</li><li>把运行期异常提升到了编译器（运行异常：代码运行之后出现的异常）</li></ol><p>弊端<br>泛型是什么类型      就只能存储什么类型的数据了</p><h3 id="2-3-泛型的定义和使用"><a href="#2-3-泛型的定义和使用" class="headerlink" title="2.3 泛型的定义和使用"></a>2.3 泛型的定义和使用</h3><h4 id="定义和使用含有泛型的类"><a href="#定义和使用含有泛型的类" class="headerlink" title="定义和使用含有泛型的类"></a>定义和使用含有泛型的类</h4><p>定义格式：</p><pre><code>修饰符 class 类名&lt;代表泛型的变量&gt; {  }</code></pre><p>使用泛型： 即什么时候确定泛型。</p><h3 id="2-4含有泛型的方法"><a href="#2-4含有泛型的方法" class="headerlink" title="2.4含有泛型的方法"></a>2.4含有泛型的方法</h3><p>定义格式：</p><pre><code>修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数){  }</code></pre><p>例如，</p><pre><code>    public &lt;MVP&gt; MVP show2(MVP mvp) {            return mvp;    }</code></pre><h3 id="2-5含有泛型的接口"><a href="#2-5含有泛型的接口" class="headerlink" title="2.5含有泛型的接口"></a>2.5含有泛型的接口</h3><p>定义格式：</p><pre><code>修饰符 interface接口名&lt;代表泛型的变量&gt; {  }</code></pre><p>例如，</p><pre><code>public interface MyGenericInterface&lt;E&gt;{}</code></pre><p>使用格式：</p><p><strong>1、定义类时确定泛型的类型</strong></p><p>例如</p><pre><code class="java">public class MyImp1 implements MyGenericInterface&lt;String&gt; {}</code></pre><p>此时，泛型E的值就是String类型。</p><p> <strong>2、始终不确定泛型的类型，直到创建对象时，确定泛型的类型</strong></p><p> 例如</p><pre><code class="java">public class MyImp2&lt;E&gt; implements MyGenericInterface&lt;E&gt; {}</code></pre><p>确定泛型：</p><pre><code class="java">/* * 使用 */public class GenericInterface {    public static void main(String[] args) {        MyImp2&lt;String&gt;  my = new MyImp2&lt;String&gt;();          my.add(&quot;aa&quot;);    }}</code></pre><h3 id="2-6-泛型通配符"><a href="#2-6-泛型通配符" class="headerlink" title="2.6  泛型通配符"></a>2.6  泛型通配符</h3><p>当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。</p><h4 id="通配符基本使用"><a href="#通配符基本使用" class="headerlink" title="通配符基本使用"></a>通配符基本使用</h4><p>泛型的通配符:<strong>不知道使用什么类型来接收的时候,此时可以使用?,?表示未知通配符。</strong></p><p>此时只能接受数据,不能往该集合中存储数据。</p><pre><code class="java">public static void main(String[] args) {    Collection&lt;Intger&gt; list1 = new ArrayList&lt;Integer&gt;();    getElement(list1);    Collection&lt;String&gt; list2 = new ArrayList&lt;String&gt;();    getElement(list2);}public static void getElement(Collection&lt;?&gt; coll){}//？代表可以接收任意类型</code></pre><blockquote><p>tips:泛型不存在继承关系 Collection<object> list = new ArrayList<string>();这种是错误的。</string></object></p></blockquote><h4 id="通配符高级使用—-受限泛型"><a href="#通配符高级使用—-受限泛型" class="headerlink" title="通配符高级使用—-受限泛型"></a>通配符高级使用—-受限泛型</h4><p>之前设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在JAVA的泛型中可以指定一个泛型的<strong>上限</strong>和<strong>下限</strong>。</p><p><strong>泛型的上限</strong>：</p><ul><li><strong>格式</strong>： <code>类型名称 &lt;? extends 类 &gt; 对象名称</code></li><li><strong>意义</strong>： <code>只能接收该类型及其子类</code></li></ul><p><strong>泛型的下限</strong>：</p><ul><li><strong>格式</strong>： <code>类型名称 &lt;? super 类 &gt; 对象名称</code></li><li><strong>意义</strong>： <code>只能接收该类型及其父类型</code></li></ul><p>比如：现已知Object类，String 类，Number类，Integer类，其中Number是Integer的父类</p><pre><code class="java">// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类public static void getElement1(Collection&lt;? extends Number&gt; coll){}// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类public static void getElement2(Collection&lt;? super Number&gt; coll){}</code></pre>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Collection集合 </tag>
            
            <tag> 泛型 </tag>
            
            <tag> Iterator迭代器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java常用API</title>
      <link href="/2019/07/16/chang-yong-api/"/>
      <url>/2019/07/16/chang-yong-api/</url>
      
        <content type="html"><![CDATA[<h3 id="API概念"><a href="#API概念" class="headerlink" title="API概念"></a>API概念</h3><p>application programming interface                                 应用程序编程接口。<br>是JDK中提供给我们现成的类可以直接拿来使用。    </p><h3 id="一个标准的类"><a href="#一个标准的类" class="headerlink" title="一个标准的类"></a>一个标准的类</h3><p>通常要满足四个组成部分<br>1.所有的成员变量都要用private<br>2.为每一个成员变量都编写Getter/Setter方法<br>3.编写一个无参构造方法<br>4.编写一个全参构造方法                    </p><h3 id="引用类型的一般使用步骤"><a href="#引用类型的一般使用步骤" class="headerlink" title="引用类型的一般使用步骤"></a>引用类型的一般使用步骤</h3><ol><li>导包 import 包路径，类名称；<br>如果需要使用的目标类，和当前类位于同一个包下，则可以省略不写<br>只有java.lang包下的内容不需要导包，其他的包都需要 import导包                          </li><li>创建<br>类名称 对象名= new 类名称();           </li><li>使用<br>对象名.成员方法名()                    </li></ol><h3 id="匿名对象（anoymous）"><a href="#匿名对象（anoymous）" class="headerlink" title="匿名对象（anoymous）"></a>匿名对象（anoymous）</h3><p>创建对象的标准格式：<br>类名称 对象名 = new 类名称（）<br>匿名对象就是只有右边的对象，没有左边的名字和复制运算符<br>new 类名称();<br>注意事项：匿名对象只能使用一次，下一次使用不得不创建一个新的对象。<br>匿名对象也可以作为方法的参数和返回值<br>使用建议：如果一个对象只需要使用唯一的一次，就可以使用匿名对象。                   </p><h3 id="Scanner类"><a href="#Scanner类" class="headerlink" title="Scanner类"></a>Scanner类</h3><p>Scanner的功能<br>可以实现键盘输入数据到程序中                        </p><h3 id="Random类"><a href="#Random类" class="headerlink" title="Random类"></a>Random类</h3><p>用来生成随机数字。        </p><h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><p>String类代表字符串。<br>程序当中所有双引号的字符串都是String类的对象。<br>特点：<br>1.字符串的内容永不可变。<br>2.正是因为字符串不可改变，所以字符串是可以共享使用的。<br>3.字符串效果上相当于char[]字符数组，但底层原理是byte[]字节数组。             </p><p>字符串常量池：只有程序当中写上双引号字符串，才在字符串常量池中。  </p><p>==是对象的地址值比较，如果确实需要字符串的内容比较扩使用两个方法<br>public boolean equqls(Object obj) 只有参数是一个字符串并且参数内容相同才会返回true<br>public boolean equalsIgnoreCase(String string) 不区分大小写参数内容相同返回true                </p><p>String当中与获取相关常用方法有<br>public int length(); 获取字符串当中含有字符个数，拿到字符串长度。<br>public String concat(String str); 将当前字符串和参数字符串拼接成返回值新的字符串<br>public char charAt(int index); 获取指定索引位置的单个字符。(索引从0开始)<br>public int indexOf(String str);                    查找参数字符串在本字符串当中首次出现索引位置，如果没有返回-1值。                 </p><p>字符串的截取方法<br>public String substring(int index); 截取从参数位置一直到字符串末尾，返回新字符串<br>public String substring(int begin,int              end)就是从begin开始，一直到end结束，中间的字符串。<br>左闭右开区间             </p><p>对于基本类型来说 ==是进行数值的比较<br>对于引用类型来说 ==是进行【地址值】的比较                         </p><p>string当中与转换相关的常用方法            </p><p>public char[] tochararry（）将当前字符串拆分为字符数组作为返回值<br>public byte[] getbytes（）获得当前字符串的底层字节数组<br>public string replace（旧的，新的）将所有旧的字符串换成新的字符串 返回替换后的字符串             </p><h4 id="字符串的分割方法"><a href="#字符串的分割方法" class="headerlink" title="字符串的分割方法"></a>字符串的分割方法</h4><p>public string[] split（string regex） 按照参数的规则，将字符串分成若干部分<br>注意事项：<br>split方法的参数其实是一个正则表达式，如果要按照英文句点来切分要写成”//.”         </p><h3 id="static类"><a href="#static类" class="headerlink" title="static类"></a>static类</h3><p>一旦用了static关键字<br>那么这样的内容不再属于自己而是属于类的 所以凡是本类的对象都共享同一份。<br>使用static修饰成员方法 不需要创建对象，直接通过类名称直接调用<br>无论是成员变量还是成员方法有了static都推荐使用类名称直接调用<br>对于本类当中的静态方法可以省略类名称              </p><p>注意事项<br>1.静态不能直接访问非静态<br>原因：在内存当中是先有的静态 后有的非静态<br>2.静态方法不能用this<br>this表示的是当前对象            </p><p>根据类名称访问静态成员变量的时候全程和对象没关系，只和类有关系。<br>静态代码块<br>当第一次使用本类时，静态代码执行唯一一次                   。<br>静态内容总是优先于非静态静态代码块比构造方法先执行<br>用来一次性的对静态成员变量进行赋值         </p><h3 id="arrys工具类"><a href="#arrys工具类" class="headerlink" title="arrys工具类"></a>arrys工具类</h3><p>是一个与数组相关的工具类，里面提供了大量的静态方法用来实现数组常见的操作<br>public static string tostring 将参数数组转换成字符串<br>public void sort 按照默认升序将数组排序<br>如果是自定义类型需要有comparator接口的支持           </p><h3 id="MATH类"><a href="#MATH类" class="headerlink" title="MATH类"></a>MATH类</h3><p>数学相关的工具类 里面提供了大量的静态方法 完成与数学相关的操作<br>public static double obs（double num）获取绝对值<br>public static double ceil （double num） 向上取整<br>public static floor（double num）向下取整<br>public static long round（double num）四舍五入         </p><h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>java.long.object类是java语言中的根类，即所有类的父类。</p><h4 id="tostring方法"><a href="#tostring方法" class="headerlink" title="tostring方法"></a>tostring方法</h4><p> String toString()       返回该对象的字符串表示；<br> 直接打印名字，其实就是调用对象的tostring<br> 如果没有重写toString方法那么打印的是对象的地址值          </p><h4 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h4><p>源码</p><pre><code>public boolean equals(Object obj) {        return (this == obj);    }</code></pre><p>参数：Object obj;可以传递任意对象<br>    ==比较运算符，返回的是一个布尔值 true false<br>    基本数据类型：比较的是值<br>    引用数据类型：比较的是两个对象的地址值         </p><pre><code>public boolean equals(Object o) {        //传递的参数obj如果是this本身直接返回true        if (o==this){            return true;        }        //如果为空直接返回false        if (o==null) {            return false;        }        //增加判断,防止类型转换异常ClassCastException        if (o instanceof Person){            //使用向下转型，把obj转换为Person类型            Person p = (Person) o;            //比较两个            if(this.name.equals(p.name) &amp;&amp; this.age==p.age){                return true;            }else {                return false;            }        }else {            return false;        }    }</code></pre><h3 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h3><p>表示日期和时间的类<br>date表示特定的瞬间，精确到毫秒；<br>毫秒值的作用，可以对时间和日期进行计算<br>把日期转换成毫秒进行计算，计算完毕，再把毫秒转换为日期         </p><p>把日期转换为毫秒<br>    当前的日期<br>    时间原点(0毫秒) 1970年1月1日         00:00:00（英国格林威治）<br>    就是计算当前日期原点之间一共经历了多少毫秒<br>把毫秒转换为日期<br><strong>注意</strong>：               中国属于东八区，会把时间增加8个小时         </p><p>构造方法</p><ul><li>public Date():默认为当前系统时间。</li><li>public Date(long date)：参数为1970年1月1日00:00:00 GMT）以来的指定毫秒数。</li></ul><p>成员方法</p><pre><code>public long getTime() 把日期对象转换成对应的时间毫秒值。</code></pre><h3 id="DateFormat类"><a href="#DateFormat类" class="headerlink" title="DateFormat类"></a>DateFormat类</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>java.text.DateFormat 是日期/时间格式化子类的抽象类，我们通过这个类可以帮我们完成日期和文本之间的转换,也就是可以在Date对象与String对象之间进行来回转换。</p><ul><li><strong>格式化</strong>：按照指定的格式，从Date对象转换为String对象。</li><li><strong>解析</strong>：按照指定的格式，从String对象转换为Date对象。</li></ul><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>DateFormat类是抽象类，不能直接使用，需要使用它的子类SimpleDateFormat</p><pre><code>DateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</code></pre><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><pre><code>DateFormat类的常用方法有：- public String format(Date date)：将Date对象格式化为字符串。- public Date parse(String source)：将字符串解析为Date对象。</code></pre><h3 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h3><h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h4><p><code>java.util.Calendar</code>是日历类，在Date后出现，替换掉了许多Date的方法。该类将所有可能用到的时间信息封装为静态成员变量，方便获取。日历类就是方便获取各个时间属性的。</p><h4 id="获取方式"><a href="#获取方式" class="headerlink" title="获取方式"></a>获取方式</h4><p>Calendar为抽象类，由于语言敏感性，Calendar类在创建对象时并非直接创建，而是通过静态方法创建，返回子类对象，如下：</p><p>Calendar静态方法</p><ul><li><code>public static Calendar getInstance()</code>：使用默认时区和语言环境获得一个日历</li></ul><pre><code>        Calendar cal = Calendar.getInstance();</code></pre><h4 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h4><p>根据Calendar类的API文档，常用方法有：</p><ul><li><code>public int get(int field)</code>：返回给定日历字段的值。</li><li><code>public void set(int field, int value)</code>：将给定的日历字段设置为给定值。</li><li><code>public abstract void add(int field, int amount)</code>：根据日历的规则，为给定的日历字段添加或减去指定的时间量。</li><li><code>public Date getTime()</code>：返回一个表示此Calendar时间值（从历元到现在的毫秒偏移量）的Date对象。</li></ul><p>Calendar类中提供很多成员常量，代表给定的日历字段：</p><table><thead><tr><th>字段值</th><th>含义</th></tr></thead><tbody><tr><td>YEAR</td><td>年</td></tr><tr><td>MONTH</td><td>月（从0开始，可以+1使用）</td></tr><tr><td>DAY_OF_MONTH</td><td>月中的天（几号）</td></tr><tr><td>HOUR</td><td>时（12小时制）</td></tr><tr><td>HOUR_OF_DAY</td><td>时（24小时制）</td></tr><tr><td>MINUTE</td><td>分</td></tr><tr><td>SECOND</td><td>秒</td></tr><tr><td>DAY_OF_WEEK</td><td>周中的天（周几，周日为1，可以-1使用）</td></tr></tbody></table><h5 id="get-set方法"><a href="#get-set方法" class="headerlink" title="get/set方法"></a>get/set方法</h5><p>get方法用来获取指定字段的值，set方法用来设置指定字段的值</p><pre><code>    public static void main(String[] args) {        Calendar cal = Calendar.getInstance();        cal.set(Calendar.YEAR, 2020);        cal.get(Calendar.MINUTE);        System.out.print(year + &quot;年&quot; + month + &quot;月&quot; + dayOfMonth + &quot;日&quot;); // 2020年1月17日    }</code></pre><h5 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h5><p>add方法可以对指定日历字段的值进行加减操作，如果第二个参数为正数则加上偏移量，如果为负数则减去偏移量。代码如：</p><pre><code>        cal.add(Calendar.DAY_OF_MONTH, 2); // 加2天        cal.add(Calendar.YEAR, -3); // 减3年</code></pre><h5 id="getTime-setTime方法"><a href="#getTime-setTime方法" class="headerlink" title="getTime/setTime方法"></a>getTime/setTime方法</h5><p>Calendar中的getTime方法并不是获取毫秒时刻，而是拿到对应的Date对象。</p><pre><code>public class Demo09CalendarMethod {    public static void main(String[] args) {        Calendar cal = Calendar.getInstance();        Date date = cal.getTime();        System.out.println(date); // Tue Jan 16 16:03:09 CST 2018    }}</code></pre><blockquote><p>小贴士：</p><p>​     西方星期的开始为周日，中国为周一。</p><p>​     在Calendar类中，月份的表示是以0-11代表1-12月。</p><p>​     日期是有大小关系的，时间靠后，时间越大。</p></blockquote><h3 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h3><p>java.lang.System<br>提供了大量静态方法可以获取与系统相关的信息或系统操作,在System类的API文档中</p><h4 id="常用的方法"><a href="#常用的方法" class="headerlink" title="常用的方法"></a>常用的方法</h4><p><code>public static Long currentTimeMillis()</code>返回当前时间</p><p><code>public static arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code><br>将指定源数组中的数组从指定位置复制到目标数组的指定位置。 </p><pre><code>src - 源数组。 srcPos - 源数组中的起始位置。 dest - 目标数组。 destPos - 目的地数据中的起始位置。 length - 要复制的数组元素的数量。 </code></pre><h3 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h3><h4 id="原理-与String区别"><a href="#原理-与String区别" class="headerlink" title="原理 与String区别"></a>原理 与String区别</h4><h5 id="Sting类"><a href="#Sting类" class="headerlink" title="Sting类"></a>Sting类</h5><p>字符串是常量:他们的值在创建之后不能更改<br>字符串的底层是被final修饰的数组,不能改变,是一个常量.<br>进行字符串的相加,内存中就会有多个字符串,占用空间多,效率低下                </p><h5 id="StringBuilder类-1"><a href="#StringBuilder类-1" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h5><p>字符串缓冲区,可以提高字符串的操作效率(看成一个长度可以变化的字符串)<br>底层也是一个数组,但是没有被final修饰,可以改变长度<br>StringBuilder在内存总始终是一个数组,占用空间少,效率高,如果超出容量会自动扩容              </p><h4 id="StringBuilder构造方法"><a href="#StringBuilder构造方法" class="headerlink" title="StringBuilder构造方法"></a>StringBuilder构造方法</h4><p><code>public StringBuilder()</code>构造一个空的StringBuilder<br><code>public StringBuilder(String str)</code>构造一个StringBuilder容器,并将字符串添加进去</p><h4 id="StringBuilder成员方法"><a href="#StringBuilder成员方法" class="headerlink" title="StringBuilder成员方法"></a>StringBuilder成员方法</h4><ul><li><code>public StringBuilder append(...)</code>：添加任意类型数据的字符串形式，并返回当前对象自身。</li><li><code>public String   toString()</code>：将当前StringBuilder对象转换为String对象。    </li></ul><p><strong>链式编程</strong><br>方法返回值是该对象可以一直调用方法 </p><h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>Java提供了两个类型系统，基本类型与引用类型，使用基本类型在于效率，然而很多情况，会创建对象使用，因为对象可以做更多的功能，如果想要我们的基本类型像对象一样操作，就可以使用基本类型对应的包装类，如下：</p><table><thead><tr><th>基本类型</th><th>对应的包装类（位于java.lang包中）</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td><strong>Integer</strong></td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td><strong>Character</strong></td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><h4 id="装箱与拆箱"><a href="#装箱与拆箱" class="headerlink" title="装箱与拆箱"></a>装箱与拆箱</h4><p>基本类型与对应的包装类对象之间，来回转换的过程称为”装箱“与”拆箱“：</p><ul><li><strong>装箱</strong>：从基本类型转换为对应的包装类对象。</li><li><strong>拆箱</strong>：从包装类对象转换为对应的基本类型。</li></ul><p>由于我们经常要做基本类型与包装类之间的转换，从Java 5（JDK 1.5）开始，基本类型与包装类的装箱、拆箱动作可以自动完成。</p><h4 id="基本类型与字符串之间的转换"><a href="#基本类型与字符串之间的转换" class="headerlink" title="基本类型与字符串之间的转换"></a>基本类型与字符串之间的转换</h4><h5 id="基本类型转换为String"><a href="#基本类型转换为String" class="headerlink" title="基本类型转换为String"></a>基本类型转换为String</h5><p>   基本类型转换String总共有三种方式，查看课后资料可以得知，这里只讲最简单的一种方式： </p><pre><code>基本类型直接与””相连接即可；如：34+&quot;&quot;</code></pre><h5 id="String转换成对应的基本类型"><a href="#String转换成对应的基本类型" class="headerlink" title="String转换成对应的基本类型"></a>String转换成对应的基本类型</h5><p>除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型：</p><ul><li><code>public static byte parseByte(String s)</code>：将字符串参数转换为对应的byte基本类型。</li><li><code>public static short parseShort(String s)</code>：将字符串参数转换为对应的short基本类型。</li><li><code>public static int parseInt(String s)</code>：将字符串参数转换为对应的int基本类型。</li></ul><blockquote><p>如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出<code>java.lang.NumberFormatException</code>异常。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> API </tag>
            
            <tag> 匿名对象 </tag>
            
            <tag> Date类 </tag>
            
            <tag> 拆箱装箱 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统复习题（大题）</title>
      <link href="/2019/06/27/cao-zuo-xi-tong-fu-xi-ti/"/>
      <url>/2019/06/27/cao-zuo-xi-tong-fu-xi-ti/</url>
      
        <content type="html"><![CDATA[<h3 id="1-pv操作"><a href="#1-pv操作" class="headerlink" title="1.pv操作"></a>1.pv操作</h3><p>p：申请资源<br>v：释放资源</p><h4 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h4><p>信号量是一个int型的变量<br>当信号量大于零时表示当前系统中某类资源的个数<br>当信号量小于零时表示当前系统中等待某类资源的个数    </p><pre><code>假定一个阅览室最多可容纳100人，读者进入和离开阅览室时都必须在门口的一个登记表进行登记，而且每次只允许一个进行登记操作，请用P、V操作实现并发的读者进程间的同步问题。</code></pre><p>先找临界资源<br>临界资源：<br>1.座位：s=100<br>2.登记表：m=1<br>注意pv操作成对出现</p><p>解：<br>s=100<br>m=1<br>void main{<br>&emsp;    cobegin<br>&emsp;&emsp;    readeri(i=1,2,3….n)<br>&emsp;coend<br>}</p><p>readeri(){<br>&emsp;    p(s);<br>&emsp;&emsp;        p(m);<br>&emsp;&emsp;阅览室有空位置找登记表进行登记<br>&emsp;&emsp;        v(m);<br>&emsp;&emsp;放回登记表学习<br>&emsp;&emsp;        p(m);<br>&emsp;&emsp;找出登记项删除登记<br>&emsp;&emsp;        v(m);<br>&emsp;&emsp;走出阅览室<br>&emsp;    V(s);        </p><p>}</p><h3 id="2-作业调度、进程调度、内存分配和设备分配"><a href="#2-作业调度、进程调度、内存分配和设备分配" class="headerlink" title="2.作业调度、进程调度、内存分配和设备分配"></a>2.作业调度、进程调度、内存分配和设备分配</h3><p><a href="https://blog.csdn.net/HaoDaWang/article/details/78598178" target="_blank" rel="noopener">作业调度的五种算法</a><br>某系统采用不能移动已在主存中作业的可变分区方式管理主存，现在有供用户使用的主存空间100K，系统配有4台磁带机，现有一作业序列：<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/os01.png" alt><br>该系统采用多道程序设计技术，对磁带机采用静态分配，请分别写出采用先来先服务和短作业优先算法选中作业执行的次序和平均周转时间。    </p><p>根据题意，我们需要先分析出各种算法的运行情况。<br>(1) 先来先服务算法的运行情况<br>先来先服务的运行情况            </p><table><thead><tr><th>序号</th><th>提交时间</th><th>进入主存时间</th><th>开始计算时间</th><th>结束计算时间</th><th>周转时间</th></tr></thead><tbody><tr><td>1</td><td>10:00</td><td>10:00</td><td>10:00</td><td>10:25</td><td>25</td></tr><tr><td>2</td><td>10:20</td><td>10:20</td><td>10:25</td><td>10:55</td><td>35</td></tr><tr><td>3</td><td>10:35</td><td>10:35</td><td>10:50</td><td>11:15</td><td>40</td></tr><tr><td>4</td><td>10:40</td><td>10:55</td><td>11:15</td><td>11:30</td><td>50</td></tr><tr><td>5</td><td>10:30</td><td>11:30</td><td>11:30</td><td>11:40</td><td>70</td></tr><tr><td>所以，平均周转时间为：(25+35+40+50+70)/5=44min。</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>(2) 按计算时间最短者优先算法。<br>序号 | 提交时间 | 进入主存时间 | 开始计算时间 | 结束计算时间 | 周转时间<br>—|—|—|—|—|—<br>1 | 10:00 | 10:00 | 10:00 | 10:25 | 25<br>2 | 10:20 | 10:20 | 10:25 | 10:55 | 35<br>3 | 10:35 | 10:35 | 11:10 | 11:30 | 55<br>4 | 10:40 | 10:55 | 10:55 | 11:10 | 30<br>5 | 10:30 | 11:30 | 11:30 | 11:40 | 70<br>所以，平均周转时间为：(25+35+30+55+70)/5=43min。</p><h3 id="3-银行家算法"><a href="#3-银行家算法" class="headerlink" title="3.银行家算法"></a>3.银行家算法</h3><p>假定系统中有五个进程{P0, P1, P2, P3, P4}和三类资源{A, B, C}，各种资源的数量分别为10、5、7，在T0时刻的资源分配情况如图所示。<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/os02.png" alt></p><p>(1) T0时刻是否安全状态？若是，请给出安全序列。<br>(2)在T0时刻若进程P1请求资源（1，0，2），是否能实施资源分配？为什么？<br>(3)在（2）的基础上，若进程P4请求资源（3，3，0），是否能实施资源分配？为什么？<br>(4)在（3）的基础上，若进程P0请求资源 （0，2，0），是否能实施资源分配？为什么？           </p><p>①安全序列为{P1, P3, P4, P2, P0}<br>②能实施资源分配Request1(1, 0, 2)≤Need1(1, 2, 2) &emsp; Request1(1, 0, 2)≤Available(3, 3, 2) &emsp;<br>&emsp;假定可为P1分配资源，利用安全性算法检查，存在安全序列为{P1, P3, P4, P0 P2}<br>③P4发出请求向量Request4(3，3，0)，系统按银行家算法进行检查：<br> Request4(3，3，0)≤Need4(4，3，1)；Request4(3，3，0)＞Available(2，3，0)，则不能实施资源分配，让P4等待。<br> ④P0发出请求向量Request0(0，2，0)，系统按银行家算法进行检查： Request0(0，2，0)≤Need0(7，4，3)；Request0(0，2，0)≤Available(2，3，0)； 先假定可为P0分配资源，利用安全性算法检查，不存在安全序列 ，</p><h3 id="4-页面置换算法"><a href="#4-页面置换算法" class="headerlink" title="4.页面置换算法"></a>4.页面置换算法</h3><h4 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h4><p>在一个请求分页存储管理系统中，一个作业的页面走向为4、3、2、1、4、3、5、4、3、2、1、5，当分配给该作业的物理块数分别为3时，试计算采用下述页面淘汰算法时的缺页率（假设开始执行时主存中没有页面），并比较所得结果。          </p><pre><code>最佳置换淘汰算法（OPT）。          先进先出淘汰算法（FIFO）。         最近最久未使用淘汰算法(LRU)。</code></pre><p><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/os03.png" alt><br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/os04.png" alt><br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/os05.png" alt></p><h4 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h4><p>某页式虚存储系统的物理空间共3KB，页面大小为1KB。一进程按下列地址顺序引用内存单元：3635、3632、1140、3584、2892、3640、0040、2148、1700、2145、3209、0000、1102、1100。如果上述数字均为十进制数，而内存中尚未装入任何页。给出使用LRU算法是的缺页次数，并与FIFO是的情况进行比较。<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/os06.png" alt></p><h4 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h4><p>某采用页式存储管理的系统中，接收了一个作业，作业执行时依次访问的页为：1，2，3，4，2，1，5，6，2，1，2，3，7。系统在主存中分配给该作业4个物理快，若开始四页已先装入主存（即作业执行前已将1、2、3、4页调入内存中，1页最先进入内存，4页最后装入内存）</p><pre><code>试分别计算采用FIFO、LRU和OPT算法时，作业执行过程中会产生多少次缺页中断 、缺页率并写出依次产生缺页中断后应淘汰的页</code></pre><p>采用先进先出调度算法会产生6次缺页中断，依次淘汰的页是1、2、3、4、5、6.<br>采用最近最少用调度算法会产生4次缺页中断，依次淘汰的页是3、4、5、6.</p><h4 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h4><p>设某分页系统中，页面大小为100字节，一个程序大小为1200字节，逻辑地址访问序列如下：10，205，110，735，603，50，815，314，432，320，225，80，130，270。系统为其分配4个主存块。</p><pre><code>试用LRU、OPT和FIFO算法算出各个页面置换算法的命中率</code></pre><p><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/os07.png" alt><br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/os08.png" alt></p><h3 id="5-地址转换"><a href="#5-地址转换" class="headerlink" title="5.地址转换"></a>5.地址转换</h3><h4 id="1-1"><a href="#1-1" class="headerlink" title="1."></a>1.</h4><p>在一分页存储管理系统中，逻辑地址长度为16位，页面大小为4096B，现有一逻辑地址为2F6AH，且第0、1、2页依次存放在物理块5、10、11中，问相应的物理地址为多少？       </p><p> 答：页号：4位 ，页内偏移地址：12位<br>        2F6AH=（0010   111101101010）<br>      页号2 存在第11块中（1011   111101101010）<br>   物理地址：BF6AH</p><h4 id="2-1"><a href="#2-1" class="headerlink" title="2."></a>2.</h4><p>设有一页式存储管理系统，向用户提供的逻辑地址空间最大为16页，每页2048B，内存总共有8个存储块，试问逻辑地址至少应为多少位？内存空间有多大？</p><p>  答：211=2048    24=16 ，所以逻辑地址至少15位。<br>内存空间：8*2048=16K    </p><h3 id="6-磁盘调度算法"><a href="#6-磁盘调度算法" class="headerlink" title="6.磁盘调度算法"></a>6.磁盘调度算法</h3><p>若磁头的当前位置为100磁道，磁头正向磁道增加方向移动。现有一磁盘读写请求队列：23，376，205，132，19，61，190，398，29，4，18，40。若采用先来先服务、最短寻道时间优先和扫描算法：<br>试计算出平均寻道长度各为多少？<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/os09.png" alt></p><h3 id="7-物理块优化"><a href="#7-物理块优化" class="headerlink" title="7.物理块优化"></a>7.物理块优化</h3><h4 id="1-2"><a href="#1-2" class="headerlink" title="1."></a>1.</h4><p>假定磁盘转速为20ms/r，磁盘格式化时每个磁道被划分为10个扇区，今有10个逻辑记录（每个记录的大型刚好与扇区大小相等）存放在同一磁道上，处理程序每次从磁盘读出一个记录后要花4ms进行处理，现要求顺序处理这10个记录，若磁头现在正处于首个逻辑记录的始点位置。<br>请问：<br>按逆时针方向安排10个逻辑记录（磁盘顺时针方向转），处理程序处理完这10个记录所需要的时间是多少<br>按最优化分布重新安排这10个逻辑记录，写出记录的安排，并计算出所需要处理的时间     </p><p><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/os10.png" alt></p><h4 id="2-2"><a href="#2-2" class="headerlink" title="2."></a>2.</h4><p>如果磁盘的每个磁道分成9个块，现有一个文件共有  A，B，…，I         9个记录，每个记录的大小与块的大小相等，设磁盘转速为27ms/r，每读出一块后需要2ms的处理时间。若忽略其他辅助时间，试问<br>如果顺序存放这些记录并顺序读取，处理该文件要多少时间？<br>如果要顺序读取该文件，记录如何存放处理时间最短？<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/os11.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 银行家算法 </tag>
            
            <tag> PV操作 </tag>
            
            <tag> 调度算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础语法（一）</title>
      <link href="/2019/06/26/java-ji-chu-yu-fa-yi/"/>
      <url>/2019/06/26/java-ji-chu-yu-fa-yi/</url>
      
        <content type="html"><![CDATA[<h3 id="1-方法重载（-overlord-）"><a href="#1-方法重载（-overlord-）" class="headerlink" title="1.方法重载（ overlord ）"></a>1.方法重载（ overlord ）</h3><h4 id="1-1为什么使用方法重载"><a href="#1-1为什么使用方法重载" class="headerlink" title="1.1为什么使用方法重载"></a>1.1为什么使用方法重载</h4><p>对于功能类似的方法来说，因为参数列表不一样，却需要记住那么多不同的方法名称过于麻烦。</p><h4 id="1-2方法重载概念"><a href="#1-2方法重载概念" class="headerlink" title="1.2方法重载概念"></a>1.2方法重载概念</h4><p>方法重载是指多个方法名称一样但参数列表不一样。只要记住一个方法名称，就能实现类似的多个功能。</p><h3 id="2-数组（array）"><a href="#2-数组（array）" class="headerlink" title="2.数组（array）"></a>2.数组（array）</h3><h4 id="2-1数组概念"><a href="#2-1数组概念" class="headerlink" title="2.1数组概念"></a>2.1数组概念</h4><p>数组是一种容器，可以同时存放多个数据值。</p><h4 id="2-2数组特点"><a href="#2-2数组特点" class="headerlink" title="2.2数组特点"></a>2.2数组特点</h4><p>1.数组是一种引用数据类型（除了八大基本数据类型都是引用类型）。<br>2.数组当中的多个数据，类型必须统一。<br>3.数组的长度在程序运行期间不可改变。<br>4.数组动态初始化时会有一个默认值。</p><h4 id="2-3内存"><a href="#2-3内存" class="headerlink" title="2.3内存"></a>2.3内存</h4><p>java的内存需要划分成五个部分<br>区域名称 | 作用<br>—|—<br>栈（stack） |存放的都是方法中的局部变量。方法的运行一定要在栈当中。<br>堆（Heap） | 凡是new出来的东西，都在堆当中。<br>方法区（Method Area） | 存储.class相关信息，包含方法的信息。<br>本地方法栈（native method stack） | JVM使用操作系统相关，与我们无关。<br>寄存器（Register） | 与cpu相关。性能非常高。 </p><p><strong>栈（stack）</strong>：存放的都是方法中的局部变量。方法的运行一定要在栈当中。<br>    局部变量：方法的参数，或者是方法｛｝内部的变量。<br>    作用域：一旦超出作用域，立刻从栈内存当中消失。<br><strong>堆（Heap）</strong>：凡是new出来的东西，都在堆当中。<br>    堆内存里面的东西都有一个地址值：16进制。<br>    堆里面的数据都有默认值。<br><strong>方法区（Method Area）</strong>：存储.class相关信息，包含方法的信息。<br><strong>本地方法栈（native method stack）</strong>：JVM使用操作系统相关，与我们无关。<br><strong>寄存器（Register）</strong>：与cpu相关。性能非常高。<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/1JAVA02.png" alt></p><h4 id="2-4数组的空指针异常"><a href="#2-4数组的空指针异常" class="headerlink" title="2.4数组的空指针异常"></a>2.4数组的空指针异常</h4><p>所有的引用类型变量，都可以赋值为一个null值。但代表期中什么都没有。<br>数组必须进行new初始化才能使用其中的元素。<br>如果只是赋值了一个null，没有进行new创建，那么将会发生空指针异常 NullPointerException</p><h3 id="3-JVM-JRE-JDK"><a href="#3-JVM-JRE-JDK" class="headerlink" title="3.JVM JRE JDK"></a>3.JVM JRE JDK</h3><p><strong>JVM（Java Virtual Machine ）</strong>：Java虚拟机，简称JVM，是运行所有Java程序的假想计算机，是Java程序的 运行环境，是Java 最具吸引力的特性之一。我们编写的Java代码，都运行在JVM上。跨平台。<br><strong>JRE  (Java Runtime Environment)</strong> ：是Java程序的运行时环境，包含JVM和运行时所需要的核心类库。<br><strong>JDK  (Java Development Kit)</strong>：是Java程序开发工具包，包含JRE和开发工具。</p><h3 id="4-跳出循环"><a href="#4-跳出循环" class="headerlink" title="4.跳出循环"></a>4.跳出循环</h3><p><strong>break</strong>：终止switch语句或者是循环。<br><strong>continue</strong>    ：结束本次循环，继续下一次循环。   </p><h3 id="5-数据类型"><a href="#5-数据类型" class="headerlink" title="5.数据类型"></a>5.数据类型</h3><p><strong>基本数据类型</strong>：字节型，整型，短整型，长整型，单精度浮点型，双精度浮点型，字符型，布尔型。<br><strong>引用数据类型</strong>：类，数组，接口。<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/1JAVA01.png" alt></p><h3 id="6-面向对象"><a href="#6-面向对象" class="headerlink" title="6.面向对象"></a>6.面向对象</h3><table><thead><tr><th>名称</th><th>概念</th></tr></thead><tbody><tr><td>面向过程</td><td>当需要实现某项功能时，每个具体的步骤都需要亲力亲为。</td></tr><tr><td>面向对象（偷懒）</td><td>当需要实现某项功能，不关心具体步骤，找一个能实现该功能的人，来帮我做事，</td></tr><tr><td>#### 6.1类和对象</td><td></td></tr><tr><td><strong>类</strong>：是一组相关属性和行为的结合。可以看成是一类事物的模版，使用事物的属性特征和行为特征来描述该类事物。</td><td></td></tr><tr><td>属性：就是该事物的状态信息。</td><td></td></tr><tr><td>行为：就是该事物能够做什么。</td><td></td></tr><tr><td><strong>对象</strong>：是一类事物的具体体现。对象是类的一个实例，必然具备该类事物的属性和行为。</td><td></td></tr><tr><td><strong>类和对象的关系</strong>：类是对一类事物的描述，是抽象的。 对象是一类事物的实例，是具体的。 类是对象的模板，对象是类的实体。</td><td></td></tr></tbody></table><h4 id="6-2对象的内存图"><a href="#6-2对象的内存图" class="headerlink" title="6.2对象的内存图"></a>6.2对象的内存图</h4><p><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/1JAVA03.png" alt></p><h4 id="6-3成员变量和局部变量"><a href="#6-3成员变量和局部变量" class="headerlink" title="6.3成员变量和局部变量"></a>6.3成员变量和局部变量</h4><h5 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h5><p>局部变量：只有方法当中才可以使用，出了方法就不能用了。<br>成员变量：在类当中整个类都可以通用。         </p><h5 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h5><p>局部变量：没有默认值。<br>成员变量：会有默认值。         </p><h5 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h5><p>局部变量：在方法内部。<br>成员变量：在方法外部，直接写在类当中。</p><h5 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h5><p>方法的参数是局部变量<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/1JAVA04.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 方法重载 </tag>
            
            <tag> 数组 </tag>
            
            <tag> java内存 </tag>
            
            <tag> JVM JRE JDK </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle数据库管理表</title>
      <link href="/2019/06/18/chuang-jian-he-guan-li-biao/"/>
      <url>/2019/06/18/chuang-jian-he-guan-li-biao/</url>
      
        <content type="html"><![CDATA[<h3 id="常见的数据库对象"><a href="#常见的数据库对象" class="headerlink" title="常见的数据库对象"></a>常见的数据库对象</h3><p><img src="https://ws1.sinaimg.cn/mw690/006lnyTwly1g70nw9gnojj30ds06ujra.jpg" alt></p><h3 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h3><p><strong>常用的数据类型</strong><br>NUMBER：数值型<br>NUMERIC：数值型<br>CHAR：定长字符串<br>VARCHAR2：可变长字符串型，与VARCHAR等价。<br>DATE：日期型</p><h3 id="引用其他用户的表"><a href="#引用其他用户的表" class="headerlink" title="引用其他用户的表"></a>引用其他用户的表</h3><p>其他用户定义的表不在当前用户的方案中<br>应该使用用户名作为前缀</p><p><strong>DEFAULT选项</strong><br>插入时为一个列指定默认值</p><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><p>Oracle 数据库中的表<br>用户定义的表：<br>数据字典(系统表)：<br>数据字典也称系统表</p><p>RWOID伪列：每个表都有一列ROWID，在创建表时Oracle数据库会自动在表中添加一列<br>ROWID伪列用于保存一条记录的实际物理地址，它可以保证在整个数据库的唯一性。</p><h3 id="使用子查询创建表"><a href="#使用子查询创建表" class="headerlink" title="使用子查询创建表"></a>使用子查询创建表</h3><p>删除表<br>DROP TABLE dept80;<br>清空表<br>删除表中所有数据<br>TRUNCATE TABLE etail_dept</p>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle数据库子查询</title>
      <link href="/2019/06/17/zi-cha-xun/"/>
      <url>/2019/06/17/zi-cha-xun/</url>
      
        <content type="html"><![CDATA[<h3 id="子查询概念"><a href="#子查询概念" class="headerlink" title="子查询概念"></a>子查询概念</h3><p>子查询也称内查询在主查询之前执行，并且只执行一次<br>子查询的结果被主查询使用<br>子查询的使用原则          </p><pre><code>子查询要包含在括号内。 将子查询放在比较条件的右侧。除非进行Top-N 分析，否则不要在子查询中使用ORDER BY 子句。单行操作符对应单行子查询，多行操作符对应多行子查询。</code></pre><p><img src="https://ws1.sinaimg.cn/mw690/006lnyTwly1g70nt6nl6pj308g05c745.jpg" alt></p><pre><code>子查询语法SELECT    select_listFROM    tableWHERE    expr operator             (SELECT    select_list               FROM        table);</code></pre><h3 id="单行子查询"><a href="#单行子查询" class="headerlink" title="单行子查询"></a>单行子查询</h3><p>单行子查询 只返回一行数据 使用单行比较操作符</p><pre><code>SELECT last_name, job_id, salaryFROM   employeesWHERE  job_id =                  (SELECT job_id                 FROM   employees                 WHERE  employee_id = 141)AND    salary &gt;                (SELECT salary                 FROM   employees                 WHERE  employee_id = 143);</code></pre><p><strong>在子查询中使用组函数</strong></p><pre><code>找到工资最少的员工SELECT last_name,job_id,salaryFROM employees WHERE salary = (                SELECT MIN(salary)                FROM employees                    );</code></pre><p><strong>在HAVING子句中使用子查询</strong></p><pre><code>SELECT department_id,MIN(salary)FROM employeesGROUP BY department_idHAVING MIN(salary)&gt;(SELECT MIN(salary)    FROM employees     WHERE department_id = 50 );</code></pre><p><strong>子查询空值问题</strong></p><pre><code>子查询中的空值不返回任何行SELECT last_name, job_idFROM   employeesWHERE  job_id =                (SELECT job_id                 FROM   employees                 WHERE  last_name = &#39;Haas&#39;);</code></pre><p><strong>单行比较有多个结果</strong></p><pre><code>SELECT employee_id, last_nameFROM   employeesWHERE  salary =                (SELECT   MIN(salary)                 FROM     employees                 GROUP BY department_id);</code></pre><h3 id="多行子查询"><a href="#多行子查询" class="headerlink" title="多行子查询"></a>多行子查询</h3><p>返回多行 使用多行比较操作符</p><p><strong>ANY操作符</strong></p><pre><code>小于任意一个SELECT employee_id,last_name,job_id,salaryFROM employeesWHERE salary &lt; ANY(SELECT salary                     FROM employees                    WHERE job_id = &#39;IT PROG&#39;)AND job_id &lt;&gt; &#39;IT_PROG&#39;;</code></pre><p>*<em>ALL操作符 *</em></p><pre><code>小于所有SELECT employee_id,last_name,job_id,salaryFROM employeesWHERE salary &lt; ALL(SELECT salary                     FROM employees                    WHERE job_id = &#39;IT PROG&#39;)AND job_id &lt;&gt; &#39;IT_PROG&#39;;</code></pre><p><strong>IN操作符</strong><br>查询那些员工是经理</p><pre><code>SELECT worker.employee_id,worker.last_nameFROM employees workerWHERE worker.employee_id IN (SELECT mgr.manager_id                            FROM employees mgr         );=======================================SELECT DISTINCT worker.employee_id,worker.last_nameFROM employees worker,employees mgrWHERE worker.employee_id = mgr.manager_id</code></pre><p><strong>NOT IN操作符</strong></p><pre><code>SELECT e.employee_id,e.first_nameFROM employees eWHERE e.employee_id NOT IN (            SELECT m.manager_id            FROM employees m            WHERE m.manager_id IS NOT NULL)=========================================SELECT manager.employee_id, manager.last_nameFROM employees worker, employees managerWHERE worker.manager_id(+)=manager.employee_idAND worker.last_name IS NULL;</code></pre><h3 id="成对比较"><a href="#成对比较" class="headerlink" title="成对比较"></a>成对比较</h3><p>查找178、174这两个员工具有相同经理和部门的其他员工信息</p><pre><code>SELECT employee_id,manager_id,department_idFROM employeesWHERE (manager_id,department_id) IN (SELECT              manager_id,department_id             FROM employees            WHERE employee_id IN (178,174))AND employee_id NOT IN (178,174);</code></pre><h3 id="不成对比较"><a href="#不成对比较" class="headerlink" title="不成对比较"></a>不成对比较</h3><pre><code>SELECT employee_id,manager_id,department_idFROM employees WHERE manager_id IN (SELECT              manager_id             FROM employees            WHERE employee_id IN (178,174))AND department_id IN (SELECT              department_id            FROM employees            WHERE employee_id IN (178,174))AND employee_id NOT IN (178,174);</code></pre><h3 id="在FROM子句中使用子查询"><a href="#在FROM子句中使用子查询" class="headerlink" title="在FROM子句中使用子查询"></a>在FROM子句中使用子查询</h3><p>子查询可以在除GROUP BY 子句之外使用。<br>在FROM子句中使用子查询时，子查询的结果作为一个表（临时表）来使用，需要给表起别名。</p><pre><code>查询哪些员工的工资大于所在部门的平均工资SELECT e.employee_id,e.last_nameFROM employees e ,(SELECT AVG(salary)    ,department_idFROM employeesGROUP BY department_id) bWHERE e.department_id=b.department_idAMD e.salary&gt;</code></pre><h3 id="单列子查询（很少用到）"><a href="#单列子查询（很少用到）" class="headerlink" title="单列子查询（很少用到）"></a>单列子查询（很少用到）</h3><pre><code>单列子查询表达式是在一行中只返回一列的子查询Oracle8i 只在下列情况下可以使用, 例如:SELECT 语句 (FROM 和 WHERE 子句)INSERT 语句中的VALUES列表中Oracle9i中单列子查询表达式可在下列情况下使用:DECODE  和 CASESELECT 中除 GROUP BY 子句以外的所有子句中在 CASE 表达式中使用单列子查询SELECT employee_id, last_name,       (CASE        WHEN department_id =        SELECT department_id FROM departments        WHERE location_id = 1800)        THEN &#39;Canada&#39; ELSE &#39;USA&#39; END) locationFROM   employees;在 ORDER BY 子句中使用单列子查询SELECT   employee_id, last_nameFROM     employees eORDER BY (SELECT department_name FROM departments d WHERE e.department_id = d.department_id);</code></pre><h3 id="相关子查询"><a href="#相关子查询" class="headerlink" title="相关子查询"></a>相关子查询</h3><p>相关子查询按照一行接一行的顺序执行，主查询的每一行都执行一次子查询<br>主查询所涉及到的记录有多少条需要过滤，就执行多少次子查询<br>查询那些员工的工资大于他所在部门的平均工资</p><pre><code>SELECT column1, column2, ... FROM   table1 WHERE  column1 operator               (SELECT  colum1, column2                       FROM    table2                       WHERE   expr1 =                                     .expr2);--查询哪些员工的工资大于他所在部门的平均工资。SELECT last_name, salary, department_idFROM   employees outerWHERE  salary &gt;(SELECT AVG(salary) FROM   employees WHERE  department_id =          outer.department_id) ;--====================================SELECT  a.last_name, a.salary,         a.department_id, b.salavgFROM    employees a, (SELECT   department_id,                       AVG(salary) salavg                      FROM     employees                      GROUP BY department_id) bWHERE   a.department_id = b.department_idAND     a.salary &gt; b.salavg;--查询哪些员工调整过两次以上的岗位。SELECT e.employee_id, last_name,e.job_idFROM   employees e WHERE  2 &lt;= (SELECT COUNT(*)             FROM   job_history              WHERE  employee_id = e.employee_id);--==================================SELECT e.employee_id,e.last_name,e.job_idFROM employees e, (SELECT employee_id,COUNT(*) mycounts                                    FROM job_history                                    GROUP BY employee_id) jhWHERE e.employee_id=jh.employee_idAND jh.mycounts&gt;=2;</code></pre><h3 id="EXISTS操作符"><a href="#EXISTS操作符" class="headerlink" title="EXISTS操作符"></a>EXISTS操作符</h3><pre><code>EXISTS 操作符检查在子查询中是否存在满足条件的行如果在子查询中存在满足条件的行:不在子查询中继续查找条件返回 TRUE如果在子查询中不存在满足条件的行:条件返回 FALSE继续在子查询中查找--EXISTS 操作符检查在子查询中是否存在满足条件的行，--即子查询有查询结果，则主查询的当前行满足查询条件。--查询哪些员工是经理。SELECT employee_id, last_name, job_id, department_idFROM   employees outerWHERE  EXISTS ( SELECT &#39;X&#39;                 FROM   employees                 WHERE  manager_id =                         outer.employee_id);--查询哪些员工是普通员工。SELECT employee_id, last_name, job_id, department_idFROM   employees outerWHERE  NOT EXISTS ( SELECT &#39;X&#39;                 FROM   employees                 WHERE  manager_id =                         outer.employee_id);</code></pre>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle数据库约束</title>
      <link href="/2019/06/16/yue-shu/"/>
      <url>/2019/06/16/yue-shu/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是约束"><a href="#什么是约束" class="headerlink" title="什么是约束"></a>什么是约束</h3><pre><code>约束是表级的强制规定约束放置在表中删除有关联关系的数据有以下五种约束:NOT NULLUNIQUE PRIMARY KEYFOREIGN KEYCHECK</code></pre><h3 id="非空约束-NOT-NULL"><a href="#非空约束-NOT-NULL" class="headerlink" title="非空约束 NOT NULL"></a>非空约束 NOT NULL</h3><pre><code>NOT NULL INSERT INTO departments(department_id,department_name)VALUES(81,NULL)</code></pre><h3 id="唯一性约束-UNIQUE"><a href="#唯一性约束-UNIQUE" class="headerlink" title="唯一性约束 UNIQUE"></a>唯一性约束 UNIQUE</h3><pre><code>可以定义在表级或列级: CREATE TABLE employees(    employee_id      NUMBER(6),    last_name        VARCHAR2(25) NOT NULL,    email            VARCHAR2(25) ,    salary           NUMBER(8,2),    commission_pct   NUMBER(2,2),    hire_date        DATE NOT NULL,...      CONSTRAINT emp_email_uk UNIQUE(email));</code></pre><h3 id="主键约束-PRIMARY-KEY"><a href="#主键约束-PRIMARY-KEY" class="headerlink" title="主键约束 PRIMARY KEY"></a>主键约束 PRIMARY KEY</h3><p>不允许出现空值 不允许出现重复值 主键既可以由一个列组成 也可以由多个列组成</p><pre><code>CREATE TABLE   departments(    department_id        NUMBER(4),    department_name      VARCHAR2(30)      CONSTRAINT dept_name_nn NOT NULL,    manager_id           NUMBER(6),    location_id          NUMBER(4),      CONSTRAINT dept_id_pk PRIMARY KEY(department_id));</code></pre><h3 id="外链约束-FOREIGN-KEY"><a href="#外链约束-FOREIGN-KEY" class="headerlink" title="外链约束 FOREIGN KEY"></a>外链约束 FOREIGN KEY</h3><p>FOREIGN KEY: 在表级指定子表中的列<br>REFERENCES: 表示在父表中的列<br>ON DELETE CASCADE:        当父表中的列被删除时，子表中相对应的列也被删除<br>ON DELETE SET NULL: 子表中相应的列置空              </p><pre><code>CREATE TABLE employees(    employee_id      NUMBER(6),    last_name        VARCHAR2(25) NOT NULL,    email            VARCHAR2(25),    salary           NUMBER(8,2),    commission_pct   NUMBER(2,2),    hire_date        DATE NOT NULL,...    department_id    NUMBER(4),    CONSTRAINT emp_dept_fk FOREIGN KEY (department_id)      REFERENCES departments(department_id),    CONSTRAINT emp_email_uk UNIQUE(email));</code></pre><h3 id="CHECK-约束"><a href="#CHECK-约束" class="headerlink" title="CHECK 约束"></a>CHECK 约束</h3><pre><code>定义每一行必须满足的条件以下的表达式是不允许的:参照CURRVAL, NEXTVAL, LEVEL, 和ROWNUM 伪列 使用 SYSDATE, UID, USER, 和 USERENV 函数在查询中涉及到其它列的值，不能使用子查询=============================================salary    NUMBER(2)     CONSTRAINT emp_salary_min              CHECK (salary &gt; 0),...</code></pre>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle数据库基础操作</title>
      <link href="/2019/06/15/oracle-shu-ju-ku-ji-chu-cao-zuo/"/>
      <url>/2019/06/15/oracle-shu-ju-ku-ji-chu-cao-zuo/</url>
      
        <content type="html"><![CDATA[<h3 id="Oracle数据库操作"><a href="#Oracle数据库操作" class="headerlink" title="Oracle数据库操作"></a>Oracle数据库操作</h3><p>登录Oracle数据库<br>打开命令行窗口         </p><pre><code>Sqlplus system/dhee—使用system用户进行登录，密码为dheeSqlplus sys/dhee—使用sys用户进行登录，密码为dheeSqlplus / as sysdba—与上一行一样</code></pre><p>创建oracle用户</p><pre><code>CREATE USER dhee IDENTIFIED　BY dhee;</code></pre><p>授予权限</p><pre><code>GRANT connect,resource TO dhee;</code></pre><p>更改用户</p><pre><code>conn dhee/dhee</code></pre><p>查看当前用户</p><pre><code>Show user</code></pre><p>生成模型数据（执行SQl脚本文件）</p><pre><code>@C:\Users\Administrator\Desktop\oracle数据库\Oracle_Script\HR_CRE.SQL</code></pre><p>查看当前用户所能够使用的表</p><pre><code>SELECT table_name    FROM user_tables;</code></pre><h3 id="常见的数据库类型"><a href="#常见的数据库类型" class="headerlink" title="常见的数据库类型"></a>常见的数据库类型</h3><pre><code>DB: 数据库DBMS: 数据库管理系统RDBMS：关系型数据库管理系统ORDBMS：对象关系型数据库管理系统常用数据库：MySQL Oracle SQL ServerNo-SQL数据库：momgoDBRedis</code></pre><h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><pre><code>SQL:结构化查询语言Select从表中获取数据SQL文的执行顺序： FROM—&gt;SELECTFROM：制定数据的来源SELECT：用于过滤列数据，即要显示那些列的数据。表：保存数据的最小单位行：指的是一条完整的记录。列：指的是某个具体的数据。注意：SQL文的执行顺序和书写顺序不一样</code></pre>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle查询操作</title>
      <link href="/2019/06/14/cha-xun-cao-zuo/"/>
      <url>/2019/06/14/cha-xun-cao-zuo/</url>
      
        <content type="html"><![CDATA[<h3 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h3><p>查询部门表的所有数据</p><pre><code>SELECT * FROM departments</code></pre><p>显示每个部门的编号和名称</p><pre><code>SELECT department_id,department_nameFROM departments;</code></pre><h3 id="书写SQL语句规则"><a href="#书写SQL语句规则" class="headerlink" title="书写SQL语句规则"></a>书写SQL语句规则</h3><pre><code>SQl语言不区分大小写SQl可以被卸载一行或者多行关键字不能被简写也不能分行写</code></pre><h3 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h3><pre><code>空值是无效的，不确定的，未知的或不可预知的值空值不是空格或者0空值是NULL，在SQL文等价于空字符串（”），有时在显示数据时空值不显示为null显示为“</code></pre><h3 id="定义别名"><a href="#定义别名" class="headerlink" title="定义别名"></a>定义别名</h3><pre><code>重命名一个列 两种方式1.紧跟列名定义 2.在列名和别名间加上’AS’关键字 如果希望在别名中包含空格或特殊的字符或者去分大小写的话，要在定义的别名上使用双引号SELECT last_name AS name, commission_pct commFROM   employees;SELECT last_name &quot;Name&quot;, salary*12 &quot;Annual Salary&quot;FROM   employees;</code></pre><h3 id="连接符"><a href="#连接符" class="headerlink" title="连接符"></a>连接符</h3><pre><code>把列与列，列与字符连接在一起。用 ‘||’表示 可以用来‘合成’列。SELECT    last_name||job_id AS &quot;Employees&quot;FROM     employees;</code></pre><h3 id="字符串与日期"><a href="#字符串与日期" class="headerlink" title="字符串与日期"></a>字符串与日期</h3><pre><code>字符串和日期要包含在单引号中字符串区分大小写日期的默认格式是  DD-MON-RR</code></pre><h3 id="删除重复行-DISTINCT"><a href="#删除重复行-DISTINCT" class="headerlink" title="删除重复行 DISTINCT"></a>删除重复行 DISTINCT</h3><pre><code>关键字’DISTINCT’ 删除重复行--如果记录有多列值，想删除重复行的话，则需要使用” DISTINCT”关键字该关键字必须写在SELECT的后面</code></pre><pre><code>SELECT DISTINCT department_idFROM employees</code></pre><h3 id="Sqlplus工具"><a href="#Sqlplus工具" class="headerlink" title="Sqlplus工具"></a>Sqlplus工具</h3><p>sqlplus工具是Oracle数据库在安装时自带的工具，以命令行窗口作为工具的窗口，并在命令行中以命名的形式加以使用</p><h3 id="描述表结构"><a href="#描述表结构" class="headerlink" title="描述表结构"></a>描述表结构</h3><p><strong>查看表结构</strong>：desc 表名<br><strong>编辑上一次执行过的SQL语句</strong>：              ed(或edit) ，执行该命令后SQL语句会出现在一个临时文件中<br>当编辑好SQL语句后，要保存并关闭，此时需要输入斜线加以执行<br>注意：临时文件中不能以分号结尾</p>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OracleSet过滤和排序</title>
      <link href="/2019/06/13/guo-lu-he-pai-xu/"/>
      <url>/2019/06/13/guo-lu-he-pai-xu/</url>
      
        <content type="html"><![CDATA[<h2 id="过滤操作"><a href="#过滤操作" class="headerlink" title="过滤操作"></a>过滤操作</h2><h3 id="WHERE子句"><a href="#WHERE子句" class="headerlink" title="WHERE子句"></a>WHERE子句</h3><p>使用WHERE子句，将不满足条件的行过滤掉<br>SQL文的执行顺序：FROM–&gt;WHERE–&gt;SELECT<br>WHERE子句写在FROM子句的后面<br>Sql语句没有赋值运算符只有比较恒等运算符=                   </p><pre><code>SELECT employee_id , last_name,job_id,department_idFROM employeesWHERE department_id = 90;</code></pre><h3 id="WHERE子句注意事项"><a href="#WHERE子句注意事项" class="headerlink" title="WHERE子句注意事项"></a>WHERE子句注意事项</h3><p>WHERE子句中不允许使用列别名<br>WHERE子句不允许使用布尔值(true,false)<br>WHERE子句中的过滤条件可以无意义，只要条件的结果为布尔值即可<br>空值参与比较运算，结果永远为False               </p><h3 id="比较条件"><a href="#比较条件" class="headerlink" title="比较条件"></a>比较条件</h3><p><img src="https://ws1.sinaimg.cn/mw690/006lnyTwly1g70nqqp03xj30kn0ftglm.jpg" alt></p><p><img src="https://ws1.sinaimg.cn/mw690/006lnyTwly1g70nqqu7m8j30qh0cvmxe.jpg" alt></p><h3 id="Between-AND"><a href="#Between-AND" class="headerlink" title="Between AND"></a>Between AND</h3><p>在使用时一定要小值在前<br>支持字符型 日期型 和 数字型                </p><pre><code>SELECT last_nameFROM employeesWHERE salary BETWEEN 1000 AND 50000</code></pre><h3 id="IN"><a href="#IN" class="headerlink" title="IN"></a>IN</h3><p>使用IN运算显示列表中的值<br>使用IN运算符时，如果列表中有空值，则忽略空值。                  </p><pre><code>SELECT employee_id, last_name, salary, manager_idFROM   employeesWHERE  manager_id IN (100, 101, 201);</code></pre><h3 id="LIKE"><a href="#LIKE" class="headerlink" title="LIKE"></a>LIKE</h3><p>使用LIKE运算选择类似的值<br>选择条件可以包含字符或数字<br>%代表零个或多个字符<br>_代表一个字符                    </p><p>“%”与“_”可以同时使用          </p><pre><code>SELECT last_nameFROM employeesWHERE last_name LIKE ‘_%’</code></pre><p><strong>注意</strong>：escape关键字所指定的字符可以是任意字符（除了%和_）             </p><h3 id="NULL"><a href="#NULL" class="headerlink" title="NULL"></a>NULL</h3><p>使用NULL判断空值            </p><pre><code>SELECT last_name, manager_idFROM   employeesWHERE  manager_id IS NULL;</code></pre><h3 id="AND"><a href="#AND" class="headerlink" title="AND"></a>AND</h3><p>左右两边条件同时满足</p><pre><code>SELECT employee_id, last_name, job_id, salaryFROM   employeesWHERE  salary &gt;=10000AND    job_id LIKE &#39;%MAN%&#39;;</code></pre><h3 id="OR"><a href="#OR" class="headerlink" title="OR"></a>OR</h3><p>左右两边条件满足任一个即可</p><pre><code>SELECT employee_id, last_name, job_id, salaryFROM   employeesWHERE  salary &gt;= 10000OR     job_id LIKE &#39;%MAN%&#39;;</code></pre><h3 id="NOT"><a href="#NOT" class="headerlink" title="NOT"></a>NOT</h3><p>否定<br>使用NOT BETWEEN…AND时，大值设置为NULL则表示NULL是最大值。<br>使用NOT BETWEEN…AND时，小值设置为NULL则表示NULL是最小值。<br>在使用NOT IN时，如果列表中有空值，则无查询结果。             </p><pre><code>SELECT last_name, job_idFROM   employeesWHERE  job_id        NOT IN (&#39;IT_PROG&#39;, &#39;ST_CLERK&#39;, &#39;SA_REP&#39;);</code></pre><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p><img src="https://ws1.sinaimg.cn/mw690/006lnyTwly1g70nqr1zjij30zr0ha74n.jpg" alt></p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="ORDER-BY-子句"><a href="#ORDER-BY-子句" class="headerlink" title="ORDER BY 子句"></a>ORDER BY 子句</h3><p>使用ORDER BY 子句进行排序<br>ASC 升序（默认）<br>DESC 降序<br>ORDER BY 子句在SELECT 语句的结尾<br>SQL文的执行顺序：FROM–&gt;WHERE–&gt;SELECT–&gt;ORDER BY                      </p><pre><code>SELECT   last_name, job_id, department_id, hire_dateFROM     employeesORDER BY hire_date ;</code></pre><p>降序排序<br>使用DESC           </p><pre><code>SELECT   last_name, job_id, department_id, hire_dateFROM     employeesORDER BY hire_date DESC ;</code></pre><h3 id="多个列排序"><a href="#多个列排序" class="headerlink" title="多个列排序"></a>多个列排序</h3><p>第一个排序规则解决不了的情况下使用第二个排序规则</p><pre><code>SELECT last_name, department_id, salaryFROM   employeesORDER BY department_id, salary DESC;</code></pre><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>可以使用列的序号（指的是列在SELECT子句中的序号，序号从1开始）进行排序。<br>可以使用不在SELECT 列表中的列排序。<br>使用多个排序规则时，先按第一个排序规则进行排序，只有第一个排序规则对应的值相同的情况下，再按第二个排序规则进行排序。            </p>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OracleSet集合运算符</title>
      <link href="/2019/06/12/set-ji-he-yun-suan-fu/"/>
      <url>/2019/06/12/set-ji-he-yun-suan-fu/</url>
      
        <content type="html"><![CDATA[<p>UNION/UNION ALL 并集操作<br>INTERSECT 交集操作<br>MINUS 补集操作          </p><h3 id="UNION-并集-去重"><a href="#UNION-并集-去重" class="headerlink" title="UNION 并集 去重"></a>UNION 并集 去重</h3><pre><code>SELECT employee_id, job_idFROM   employeesUNIONSELECT employee_id, job_idFROM   job_history;</code></pre><h3 id="UNION-ALL-不去重并集"><a href="#UNION-ALL-不去重并集" class="headerlink" title="UNION ALL 不去重并集"></a>UNION ALL 不去重并集</h3><pre><code>SELECT employee_id, job_id, department_idFROM   employeesUNION ALLSELECT employee_id, job_id, department_idFROM   job_historyORDER BY  employee_id;</code></pre><h3 id="INTERSECT-交集操作-去重"><a href="#INTERSECT-交集操作-去重" class="headerlink" title="INTERSECT 交集操作 去重"></a>INTERSECT 交集操作 去重</h3><pre><code>SELECT employee_id, job_idFROM   employeesINTERSECTSELECT employee_id, job_idFROM   job_history;</code></pre><h3 id="MINUS补集操作"><a href="#MINUS补集操作" class="headerlink" title="MINUS补集操作"></a>MINUS补集操作</h3><pre><code>SELECT employee_id,job_idFROM   employeesMINUSSELECT employee_id,job_idFROM   job_history;</code></pre><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>类型要一样</li><li>括号可改变执行顺序</li><li>ORDER BY 子句 只能在语句的最后出现</li><li>除 UNION ALL之外，系统会自动将重复的记录删除</li><li>除 UNION ALL之外，系统自动按照第一个查询中的第一个列的升序排列 </li></ol><pre><code>匹配SELECT 语句举例SELECT department_id, TO_NUMBER(null)        location, hire_dateFROM   employeesUNIONSELECT department_id, location_id,  TO_DATE(null)FROM   departments;————————————————————————————————————————————SELECT employee_id, job_id,salaryFROM   employeesUNIONSELECT employee_id, job_id,0FROM   job_history;————————————————————————————————————————————COLUMN a_dummy NOPRINTSELECT &#39;sing&#39; AS &quot;My dream&quot;, 3 a_dummyFROM dualUNIONSELECT &#39;I&#39;&#39;d like to teach&#39;, 1FROM dualUNION SELECT &#39;the world to&#39;, 2FROM dualORDER BY 2;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle单行函数</title>
      <link href="/2019/06/11/dan-xing-han-shu/"/>
      <url>/2019/06/11/dan-xing-han-shu/</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/mw690/006lnyTwly1g70nnpu8ooj30xr0nvdis.jpg" alt></p><ol><li>操作数据对象</li><li>接受参数返回一个结果</li><li>只对一行进行操作</li><li>每行返回一个结果</li><li>可以转换数据类型</li><li>可以嵌套</li><li>参数可以是一列或一个表达式</li></ol><pre><code>写法    function_name [(arg1, arg2,...)]</code></pre><p>——在SQL语法个事说明中，中括号表示可选的意思<br>——dual称为伪表，里面只有一行一列数据，它主要用于测试</p><h3 id="字符函数"><a href="#字符函数" class="headerlink" title="字符函数"></a>字符函数</h3><p><img src="https://ws1.sinaimg.cn/mw690/006lnyTwly1g70nnq93rkj312s0rin0g.jpg" alt></p><h4 id="大小写处理函数"><a href="#大小写处理函数" class="headerlink" title="大小写处理函数"></a>大小写处理函数</h4><p>INITCAP<br>首字母大写后面小写</p><pre><code>SELECT INITCAP(‘abc def%dsad1231dawwe’)FROM dual;</code></pre><p>LOWER:转换成小写<br>UPPER:转换成大写</p><h5 id="字符处理函数"><a href="#字符处理函数" class="headerlink" title="字符处理函数"></a>字符处理函数</h5><p><img src="https://ws1.sinaimg.cn/mw690/006lnyTwly1g70nnpgmh7j30xu0gsdgp.jpg" alt></p><p>SUNSTR<br>截取<br>——第二个参数表示从第几个开始截取              </p><pre><code>SELECT SUBSTR(‘Hello World!’,3),SUBSTR(‘Hello World!’,3,5),SUBSTR(‘Hello World!’,-5,3)FROM dual;</code></pre><p>INSTR<br>获取字符位置<br>–第三个参数为正整数表示从左向右搜索；为负数表示从右数第几个字符开始并且从右向左<br>–第四个字符表示第几次出现的<br>搜索</p><pre><code>SELECT INSTR(‘Hello World!’,’W’),INSTR(‘Hello World!’,’o’,2), INSTR(‘Hello World!’,’l’,4,2), INSTR(‘Hello World!’,’l’,-4,2)FROM dual</code></pre><p>TRIM<br>去除元素            </p><pre><code>SELECT TRIM(‘       Hello  World!      ’),TRIM(‘k’FROM’kkkkkkokokhelloworldkkkkkkkkk’)FROM dual</code></pre><h3 id="数字函数"><a href="#数字函数" class="headerlink" title="数字函数"></a>数字函数</h3><p>ROUND:四舍五入<br>TRUNC:截断<br>——ROUND和TRUNC的第二个参数可以省略（等价于第二个参数为0），省略表示保留到个位<br>MOD求余</p><h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><p>日期型常量必须写在单引号中。’02-8月-19’<br>日期格式敏感，默认的日期格式是 DD-MON-RR，DD表示日，MON表示月，RR表示年。<br>SYSDATE函数用于返回数据库服务器端当前日期时间。<br>日期的数学运算符：<br>        日期 + 天=日期<br>        日期 -  天=日期<br>        日期 – 日期=天<br>如果想加减小时，分钟，秒的话，则需要把他们换算成天           </p><pre><code>SELECT SYSDATE+250,SYSDATE-250,SYSDATE-hire_dateFROM employees;</code></pre><p><strong>计算两个日期相差月份</strong></p><pre><code>MONTHS_BETWEEN (&#39;01-SEP-95&#39;,&#39;11-JAN-94&#39;)</code></pre><p><strong>加上月份</strong></p><pre><code>ADD_MONTHS (&#39;11-JAN-94&#39;,6)</code></pre><p><strong>下一个星期</strong></p><pre><code>NEXT_DAY (&#39;01-SEP-95&#39;,&#39;FRIDAY&#39;)</code></pre><p><strong>上一个星期</strong></p><pre><code>LAST_DAY(&#39;01-FEB-95&#39;)</code></pre><h3 id="转换函数"><a href="#转换函数" class="headerlink" title="转换函数"></a>转换函数</h3><h4 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h4><h4 id="显式转换"><a href="#显式转换" class="headerlink" title="显式转换"></a>显式转换</h4><h5 id="TO-CHAR函数"><a href="#TO-CHAR函数" class="headerlink" title="TO_CHAR函数"></a>TO_CHAR函数</h5><p>——TO_CHAR的第二个参数与结果对应，即把第一个参数值按照第二个参数的要求</p><p>对日期的转换<br>格式参数:</p><ol><li>必须包含在单引号中而且区分大小写。</li><li>可以包含任意的有效的日期格式。</li><li>可以使用 fm 4. 去掉多余的空格或者前导零。</li><li>与日期参数之间用逗号隔开。</li></ol><pre><code>基础格式TO_CHAR(date, &#39;format_model&#39;)</code></pre><pre><code>SELECT TO_CHAR(SYSDATE,&#39;YYYY-MM-DD DAY HH24:MI:SS AM&#39;),TO_CHAR(SYSDATE,&#39;FMYYYY-MM-DD DAY HH24:MI:SS AM&#39;),TO_CHAR(SYSDATE,&#39;YYYY&quot;年&quot;-MM&quot;月&quot;-DD&quot;日&quot; DAY HH24:MI:SS AM&#39;)FROM dual;</code></pre><p>对数字的转换</p><pre><code>TO_CHAR(number, &#39;format_model&#39;)</code></pre><p><img src="https://ws1.sinaimg.cn/mw690/006lnyTwly1g70nnoyd4pj30xe0ddwen.jpg" alt></p><pre><code>SELECT TO_CHAR(123456.8759,&#39;$999,999,999.99&#39;)FROM dual;结果为：$123,456.88</code></pre><h5 id="TO-NUMBER"><a href="#TO-NUMBER" class="headerlink" title="TO_NUMBER"></a>TO_NUMBER</h5><p>使用 TO_NUMBER 函数将字符转换成数字:</p><pre><code>TO_NUMBER(char[, &#39;format_model&#39;])</code></pre><h5 id="TO-DATE"><a href="#TO-DATE" class="headerlink" title="TO_DATE"></a>TO_DATE</h5><p>使用 TO_DATE 函数将字符转换成日期:</p><pre><code>TO_DATE(char[, &#39;format_model&#39;])</code></pre><h3 id="通用函数"><a href="#通用函数" class="headerlink" title="通用函数"></a>通用函数</h3><p>这些函数可以用于任何数据类型，同时也适用于空值</p><pre><code>NVL (expr1, expr2)NVL2 (expr1, expr2, expr3)NULLIF (expr1, expr2)COALESCE (expr1, expr2, ..., exprn)</code></pre><h4 id="NVL-函数"><a href="#NVL-函数" class="headerlink" title="NVL 函数"></a>NVL 函数</h4><p>将空值转换成一个已知的值<br>可以使用的数据类型有日期、字符和数字。<br>参数的数据类型必须一致:                 </p><pre><code>SELECT first_name,NVL(commission_pct,0)FROM employees;</code></pre><h4 id="NVL2-函数"><a href="#NVL2-函数" class="headerlink" title="NVL2 函数"></a>NVL2 函数</h4><p>第一个参数值不是空值，则返回第二个参数值，第一个参数值是空值，则返回第三个参数值。</p><pre><code>SELECT NVL2(commission_pct,1,9999)FROM employees;</code></pre><h4 id="NULLIF函数"><a href="#NULLIF函数" class="headerlink" title="NULLIF函数"></a>NULLIF函数</h4><p>两个参数值不相等，则返回第一个参数值，两个参数值相等则返回NULL。</p><pre><code>SELECT first_name,LENGTH(first_name) &quot;expr1&quot;,            last_name,LENGTH(last_name) &quot;expr2&quot;,            NULLIF(LENGTH(first_name),LENGTH(last_name)) as &quot;结果&quot;FROM employees;</code></pre><h4 id="COALESCE函数"><a href="#COALESCE函数" class="headerlink" title="COALESCE函数"></a>COALESCE函数</h4><p>返回第一个不为NULL的值</p><pre><code>SELECT COALESCE(commission_pct,salary,100)FROM employees</code></pre><h3 id="嵌套函数"><a href="#嵌套函数" class="headerlink" title="嵌套函数"></a>嵌套函数</h3><p>单行函数可以嵌套，嵌套函数的执行顺序是由内到外<br><img src="https://ws1.sinaimg.cn/mw690/006lnyTwly1g70nnoonkvj30e0051q31.jpg" alt></p><pre><code>SELECT last_name,       NVL(TO_CHAR(manager_id), &#39;No Manager&#39;)FROM   employeesWHERE  manager_id IS NULL;</code></pre><h3 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h3><pre><code>在 SQL 语句中使用IF-THEN-ELSE 逻辑。使用两种方法:CASE 表达式DECODE 函数</code></pre><h4 id="CASE-表达式"><a href="#CASE-表达式" class="headerlink" title="CASE 表达式"></a>CASE 表达式</h4><p>Case表达式，是可以在sql中使用if ..then..else的逻辑判断，而避免使用PL/SQL的有效方法。<br>——CASE表达式有两种写法，第一种写法只能进行相等性比较，第二种写法可以使用任意比较运算符。  </p><pre><code>SELECT last_name,job_id,salary,CASE job_id WHEN &#39;IT_PROG&#39; THEN 1.10*salary         WHEN &#39;ST_CLERK&#39; THEN 1.15*salary         WHEN &#39;SA_REP&#39; THEN 1.20*salaryELSE     salaryEND AS &quot;Salary&quot;FROM employees</code></pre><pre><code>SELECT last_name,job_id,salary,CASE WHEN job_id LIKE &#39;%REP%&#39; THEN 0.001*salaryELSE     salaryEND AS &quot;Salary&quot;FROM employees</code></pre><h4 id="DECODE-函数"><a href="#DECODE-函数" class="headerlink" title="DECODE 函数"></a>DECODE 函数</h4><p>语法：<br>decode(条件，值1，返回值1，值2，返回值2，…值n,返回值n，缺省值) [1] </p><pre><code>SELECT last_name,job_id,salary,    DECODE(job_id,   &#39;IT_PROG&#39;, 1.10*salary,                   &#39;ST_CLERK&#39;, 1.15*salary,                                           &#39;SA_REP&#39;, 1.20*salary,            salary) as &quot;Salary&quot;FROM employees</code></pre>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle多表查询</title>
      <link href="/2019/06/10/duo-biao-cha-xun/"/>
      <url>/2019/06/10/duo-biao-cha-xun/</url>
      
        <content type="html"><![CDATA[<h3 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h3><p>笛卡尔积：一个表中的每一条记录都分别和另外一个表中的每一条记录连接，就形成了笛卡尔积<br>笛卡尔积中的记录是不准确的           </p><p>多表连接查询时需要使用连接条件，即一个表中的外键等于另一个表中的主键。 </p><p><strong>主键</strong>：由一个表中的一列或多列组成，能够唯一标识一条记录，主键不能重复，并且主键不允许为空。<br>在实际开发时，主键通常是一个无实际意义的列值<br><strong>外键</strong>：一个表中的主键在另外一个表中使用，则称为外键。 外键允许为空，也允许重复值。</p><h3 id><a href="#" class="headerlink" title></a><img src="https://ws1.sinaimg.cn/mw690/006lnyTwly1g70nydxmjtj30og0h0my4.jpg" alt></h3><h3 id="等值连接"><a href="#等值连接" class="headerlink" title="等值连接"></a>等值连接</h3><p>等值连接是关系运算-连接运算的一种常用的连接方式。是条件连接（或称θ连接）在连接运算符为“=”号时，即θ=0时的一个特例。</p><pre><code>SELECT    table1.column, table2.columnFROM    table1, table2WHERE    table1.column1 = table2.column2;</code></pre><pre><code>SELECT e.employee_id,e.last_name,e.salary,d.department_name,l.city,c.country_name,r.region_name,j.job_titleFROM employees e,departments d,locations l,countries c,regions r,jobs jWHERE e.department_id=d.department_idAND l.country_id=c.country_idAND c.region_id=r.region_idAND e.job_id=j.job_idAND d.location_id=l.location_id</code></pre><h3 id="非等值连接"><a href="#非等值连接" class="headerlink" title="非等值连接"></a>非等值连接</h3><pre><code>SELECT e.last_name,e.salary,j.grade_levelFROM employees e,job_grades jWHERE  e.salary    BETWEEN j.lowest_sal AND j.highest_sal</code></pre><h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><p>使用外连接可以查询不满足连接条件的数据。<br>外连接的符号是 (+)。</p><h4 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h4><pre><code>SELECT e.last_name, e.department_id, d.department_nameFROM   employees e, departments dWHERE  e.department_id = d.department_id(+) ;</code></pre><h4 id="右外连接"><a href="#右外连接" class="headerlink" title="右外连接"></a>右外连接</h4><pre><code>SELECT e.last_name, e.department_id, d.department_nameFROM   employees e, departments dWHERE  e.department_id(+) = d.department_id ;</code></pre><h3 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h3><p>一张表使用多份</p><pre><code>SELECT e.first_name name,m.first_name manngerFROM employees e ,employees mWHERE e.manager_id=m.employee_id</code></pre><hr><h2 id="SQL-1999规范"><a href="#SQL-1999规范" class="headerlink" title="SQL:1999规范"></a>SQL:1999规范</h2><p>SQL99规范是ANSI中的一个标准。</p><h3 id="CROSS-JOIN"><a href="#CROSS-JOIN" class="headerlink" title="CROSS JOIN"></a>CROSS JOIN</h3><p>使用CROSS JOIN 子句使连接的表产生叉积。<br>叉积和笛卡尔积是相同的。                     </p><pre><code>SELECT last_name,department_nameFROM employees CROSS JOIN departments;==========================SELECT last_name,department_nameFROM employees,departments;</code></pre><h3 id="自然连接-NATURAL-JOIN"><a href="#自然连接-NATURAL-JOIN" class="headerlink" title="自然连接 NATURAL JOIN"></a>自然连接 NATURAL JOIN</h3><p>NATURAL JOIN 子句，会以两个表中具有相同名字的列做为条件创建等值连接。<br>在表中查询所有满足等值条件的数据。<br>如果只是列名相同而数据类型不同，则会产生错误。                  </p><pre><code>SELECT department_id, department_name,       location_id, cityFROM   departmentsNATURAL JOIN locations ;--===================================SELECT department_id, department_name,       departments.location_id, cityFROM   departments,locations WHERE departments.location_id=locations.location_id;</code></pre><p>以两个表中具有相同名字的列来连接。</p><h3 id="USING子句创建连接"><a href="#USING子句创建连接" class="headerlink" title="USING子句创建连接"></a>USING子句创建连接</h3><p>在NATURAL JOIN子句创建等值连接时，<br>如果有多个名字相同，数据类型不同的列，<br>那么可以使用 USING 子句指定等值连接中需要用到的列。<br>使用 USING 可以在有多个列满足条件时进行选择。<br>不要给选中的列使用表名前缀或别名。<br>NATURAL JOIN 和 USING 子句不能同时使用。                  </p><pre><code>SELECT e.employee_id, e.last_name, department_id FROM   employees e JOIN departments dUSING (department_id) ;--========================================SELECT e.employee_id, e.last_name, d.department_id FROM   employees e , departments dWHERE e.department_id=d.department_id;</code></pre><h3 id="使用ON子句创建连接"><a href="#使用ON子句创建连接" class="headerlink" title="使用ON子句创建连接"></a>使用ON子句创建连接</h3><p>自然连接总是以具有相同名字的列为连接条件的，可以使用ON子句制定额外的连接条件，这个连接条件是与其它条件分开的具有很高的易读性</p><pre><code>SELECT e.employee_id, e.last_name, e.department_id,        d.department_id, d.location_idFROM   employees e JOIN departments dON     (e.department_id = d.department_id);</code></pre><h3 id="内连接-与-外连接"><a href="#内连接-与-外连接" class="headerlink" title="内连接 与 外连接"></a>内连接 与 外连接</h3><p>在SQL:1999中，内连接值返回满足条件的数据<br>两个表在连接过程除了返回满足连接条件的行以外还返回左（或右）表中不满足条件的行，这种连接称为左（或右外连接）<br>两个表在连接过程中除了返回满足连接条件的行以外还返回两个表中不满足条件的行 ，这种连接称为满 外联接。</p><h3 id="左外链接"><a href="#左外链接" class="headerlink" title="左外链接"></a>左外链接</h3><p><strong>LEFT OUTER JOIN ON</strong></p><pre><code>SELECT e.last_name,e.department_id,d.department_nameFROM employees eLEFT OUTER JOIN departments dON (e.department_id = d.department_id )</code></pre><h3 id="右外链接"><a href="#右外链接" class="headerlink" title="右外链接"></a>右外链接</h3><p><strong>RIGHT OUTER JOIN ON</strong></p><pre><code>SELECT  e.last_name,e.department_id,d.department_nameFROM employees eRIGHT OUTER JOIN departments dON (e.department_id = d.department_id )</code></pre><h3 id="满外链接"><a href="#满外链接" class="headerlink" title="满外链接"></a>满外链接</h3><p><strong>FULL OUTER JOIN ON</strong></p><pre><code>SELECT   e.last_name,e.department_id,d.department_nameFROM employees eFULL OUTER JOIN departments dON (e.department_id = d.department_id )</code></pre><h3 id="增加连接条件"><a href="#增加连接条件" class="headerlink" title="增加连接条件"></a>增加连接条件</h3><p>（最好不用可能会得到不正确的结果最好在WHERE子句中编写过滤条件）<br><strong>AND</strong> </p><pre><code>SELECT e.employee_id, e.last_name, e.department_id,        d.department_id, d.location_idFROM   employees e JOIN departments dON     (e.department_id = d.department_id);AND    e.manager_id = 149 </code></pre><p>列出所有员工的年薪,部门名称，显示员工号，员工姓，员工工资，员工奖金比例，员工从工作以来的工资合计<br>员工年薪计算方式 12个月工资+奖金</p><pre><code>SELECT e.salary*12+e.salary*NVL(e.commission_pct,0)*12 ,d.department_name,e.employee_id,e.last_name,e.commission_pct,TRUNC(MONTHS_BETWEEN(sysdate,e.hire_date))*(e.salary+e.salary*NVL(e.commission_pct,0))+TRUNC(MONTHS_BETWEEN(sysdate,e.hire_date)/12)*salary*2FROM employees e LEFT OUTER JOIN departments dON e.department_id=d.department_id</code></pre>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>AdminLTE的基本使用</title>
      <link href="/2019/06/10/adminlte-de-ji-ben-shi-yong/"/>
      <url>/2019/06/10/adminlte-de-ji-ben-shi-yong/</url>
      
        <content type="html"><![CDATA[<h2 id="AdminLTE-基本使用"><a href="#AdminLTE-基本使用" class="headerlink" title="AdminLTE 基本使用"></a>AdminLTE 基本使用</h2><h3 id="1-AdminLTE简介"><a href="#1-AdminLTE简介" class="headerlink" title="1.AdminLTE简介"></a>1.AdminLTE简介</h3><p>AdminLTE是一款建立在bootstrap和jquery之上的开源的模板主题工具。<br><img src="https://camo.githubusercontent.com/e3bbc646d6ff473da2dd6cede2c968846a6982a6/68747470733a2f2f61646d696e6c74652e696f2f41646d696e4c5445322e706e67" alt="image"></p><h3 id="2-AdminLTE下载"><a href="#2-AdminLTE下载" class="headerlink" title="2.AdminLTE下载"></a>2.AdminLTE下载</h3><p>英文版下载地址：<a href="https://github.com/almasaeed2010/AdminLTE" target="_blank" rel="noopener">https://github.com/almasaeed2010/AdminLTE</a><br>中文版下载地址：<a href="https://github.com/itheima2017/adminlte2-itheima" target="_blank" rel="noopener">https://github.com/itheima2017/adminlte2-itheima</a></p><h3 id="3-AdminLTE结构介绍"><a href="#3-AdminLTE结构介绍" class="headerlink" title="3.AdminLTE结构介绍"></a>3.AdminLTE结构介绍</h3><p>AdminLTE依赖于两个框架Bootstrap3与JQuery1.11   </p><p><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/AdminLTE03.png" alt><br>在目录结构中assets、modules、pages、 plugins都是前端开发时所使用到的，最终发布的就是release。所以对于我们使用中文版来说，我们只需要关注release目录下的结构就可以。    </p><h3 id="4-布局皮肤"><a href="#4-布局皮肤" class="headerlink" title="4.布局皮肤"></a>4.布局皮肤</h3><p><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/AdminLTE02.png" alt></p><h4 id="4-1布局"><a href="#4-1布局" class="headerlink" title="4.1布局"></a>4.1布局</h4><p>.wrapper包住了body下的所有代码<br>.main-header里是网站的logo和导航栏的代码<br>.main-sidebar里是用户面板和侧边栏菜单的代码<br>.content-wrapper里是页面的页面和内容区域的代码 .main-footer里是页脚的代码<br>.control-sidebar里是页面右侧侧边栏区域的代码<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/AdminLTE06.png" alt></p><h4 id="4-2布局选项"><a href="#4-2布局选项" class="headerlink" title="4.2布局选项"></a>4.2布局选项</h4><p>fixed：固定<br>layout-boxed：盒子布局<br>ayout-top-nav：顶部隐藏<br>sidebar-collapse：侧边栏隐藏<br>sidebar-mini：侧边栏隐藏时有小图标      </p><h4 id="4-3皮肤"><a href="#4-3皮肤" class="headerlink" title="4.3皮肤"></a>4.3皮肤</h4><p>skin-blue：蓝色<br>skin-black：黑色<br>skin-purple：紫色<br>skin-yellow：黄色<br>skin-red：红色<br>skin-green：绿色<br>以上项我们可以查看start.html页面中查看。    </p><hr><h2 id="在SSM中的使用"><a href="#在SSM中的使用" class="headerlink" title="在SSM中的使用"></a>在SSM中的使用</h2><h3 id="1-导入到HBuilder"><a href="#1-导入到HBuilder" class="headerlink" title="1.导入到HBuilder"></a>1.导入到HBuilder</h3><p><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/AdminLTE01.png" alt></p><h3 id="2-在page目录下选择需要的页面"><a href="#2-在page目录下选择需要的页面" class="headerlink" title="2.在page目录下选择需要的页面"></a>2.在page目录下选择需要的页面</h3><p><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/AdminLTE04.png" alt></p><h3 id="3-对页面进行个性化修改"><a href="#3-对页面进行个性化修改" class="headerlink" title="3.对页面进行个性化修改"></a>3.对页面进行个性化修改</h3><p><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/AdminLTE05.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 主题模版 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AdminLTE </tag>
            
            <tag> bootstrap </tag>
            
            <tag> 主题模版 </tag>
            
            <tag> 后台模版 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SVN入门</title>
      <link href="/2019/06/09/svn-ru-men/"/>
      <url>/2019/06/09/svn-ru-men/</url>
      
        <content type="html"><![CDATA[<h2 id="1-SVN介绍"><a href="#1-SVN介绍" class="headerlink" title="1.SVN介绍"></a>1.SVN介绍</h2><p>SVN是Subversion的简称，是一个自由开源的版本控制系统。<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/SVN38.png" alt></p><h4 id="1-1操作解释"><a href="#1-1操作解释" class="headerlink" title="1.1操作解释"></a>1.1操作解释</h4><p>checkout：把整个项目代码下载到本地<br>update：将本地的源码更新至服务器的最新版本<br>commit：将本地源码更新内容提交到服务器  </p><h4 id="1-2避免干扰"><a href="#1-2避免干扰" class="headerlink" title="1.2避免干扰"></a>1.2避免干扰</h4><h5 id="1-2-1复制-修改-合并方案-Subversion默认的模式"><a href="#1-2-1复制-修改-合并方案-Subversion默认的模式" class="headerlink" title="1.2.1复制-修改-合并方案(Subversion默认的模式)"></a>1.2.1复制-修改-合并方案(Subversion默认的模式)</h5><p>每一个用户读取库在本地建立私人副本，在本地工作修改，最终合并成为最终版本，需要人工去整合判断正误。</p><h5 id="1-2-2锁定-修改-解锁方案"><a href="#1-2-2锁定-修改-解锁方案" class="headerlink" title="1.2.2锁定-修改-解锁方案"></a>1.2.2锁定-修改-解锁方案</h5><p>在这样的模型里，在一个时间段里配置库的一个文件只允许被一个人修改。 此模式不适合软件开发这种工作。 </p><h4 id="1-3安装位置"><a href="#1-3安装位置" class="headerlink" title="1.3安装位置"></a>1.3安装位置</h4><p>Subversion支持Linux和Windows，更多是安装在Linux下。         </p><h4 id="1-4运行方式"><a href="#1-4运行方式" class="headerlink" title="1.4运行方式"></a>1.4运行方式</h4><p>独立服务器和借助apache运行。</p><h4 id="1-5存储方式"><a href="#1-5存储方式" class="headerlink" title="1.5存储方式"></a>1.5存储方式</h4><p>BDB与FSFS<br>BDB一种事务安全型表类型和FSFS一种不需要数据库的存储系统。<br>因为BDB方式在服务器中断时，有可能锁住数据，所以还是FSFS方式更安全一点。</p><h2 id="2-SVN使用"><a href="#2-SVN使用" class="headerlink" title="2 SVN使用"></a>2 SVN使用</h2><p>window下svn服务器VisualSVN<br>客户端工具TortoiseSVN<br>idea svn插件</p><h3 id="2-1-服务器端VisualSVN安装与配置"><a href="#2-1-服务器端VisualSVN安装与配置" class="headerlink" title="2.1 服务器端VisualSVN安装与配置"></a>2.1 服务器端VisualSVN安装与配置</h3><h4 id="2-1-1官网下载visualSVN"><a href="#2-1-1官网下载visualSVN" class="headerlink" title="2.1.1官网下载visualSVN"></a>2.1.1官网下载visualSVN</h4><p><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/SVN01.png" alt></p><h4 id="2-1-2安装visualSVN"><a href="#2-1-2安装visualSVN" class="headerlink" title="2.1.2安装visualSVN"></a>2.1.2安装visualSVN</h4><p><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/SVN02.png" alt><br>location：安装位置<br>Repositories：仓库位置<br>存储方式使用FSFS<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/SVN03.png" alt></p><h4 id="2-1-3visualSVN使用"><a href="#2-1-3visualSVN使用" class="headerlink" title="2.1.3visualSVN使用"></a>2.1.3visualSVN使用</h4><p>创建组 创建用户<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/SVN04.png" alt><br>分配权限 创建仓库 复制仓库的URL输入浏览器中成功访问<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/SVN05.png" alt><br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/SVN06.png" alt></p><h3 id="2-2-客户端TortoiseSVN安装与配置"><a href="#2-2-客户端TortoiseSVN安装与配置" class="headerlink" title="2.2 客户端TortoiseSVN安装与配置"></a>2.2 客户端TortoiseSVN安装与配置</h3><p>TortoiseSVN是一个基于windows系统的svn客户端图形化界面</p><h4 id="2-2-1-TortoiseSVN的下载与安装"><a href="#2-2-1-TortoiseSVN的下载与安装" class="headerlink" title="2.2.1 TortoiseSVN的下载与安装"></a>2.2.1 TortoiseSVN的下载与安装</h4><p><a href="https://tortoisesvn.net/downloads.html" target="_blank" rel="noopener">https://tortoisesvn.net/downloads.html</a> 官网下载<br>安装注意 选择第二个选项 要不然没有svn.exe文件<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/SVN39.png" alt>    </p><h4 id="2-2-2-TortoiseSVN的使用"><a href="#2-2-2-TortoiseSVN的使用" class="headerlink" title="2.2.2 TortoiseSVN的使用"></a>2.2.2 TortoiseSVN的使用</h4><p>新建文件夹 右键就会看到tortoiseSVN 点击Repo-browser浏览仓库<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/SVN07.png" alt><br>输入认证信息赋予文件夹权限<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/SVN08.png" alt><br>右键setting 清理认证信息<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/SVN09.png" alt></p><h4 id="2-2-3-TortoiseSVN的操作"><a href="#2-2-3-TortoiseSVN的操作" class="headerlink" title="2.2.3 TortoiseSVN的操作"></a>2.2.3 TortoiseSVN的操作</h4><p>通过checkout从仓库下载文件<br>新建文件 右键add 然后commit message内填写修改信息</p><p><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/SVN10.png" alt><br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/SVN11.png" alt>       </p><p><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/SVN12.png" alt><br>update 更新服务器<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/SVN13.png" alt><br>show log查看历史版本<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/SVN14.png" alt></p><h4 id="2-2-4-导入与导出"><a href="#2-2-4-导入与导出" class="headerlink" title="2.2.4 导入与导出"></a>2.2.4 导入与导出</h4><p>Import将本地资源导入到svn服务器<br>Export导出项目，和checkout的区别,它不存在.svn隐藏文件<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/SVN16.png" alt></p><h4 id="2-2-5-冲突问题"><a href="#2-2-5-冲突问题" class="headerlink" title="2.2.5 冲突问题"></a>2.2.5 冲突问题</h4><p>遇到冲突 Edit confilcts解决冲突<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/SVN20.png" alt></p><h2 id="3-IDEA中使用TortoiseSVN"><a href="#3-IDEA中使用TortoiseSVN" class="headerlink" title="3.IDEA中使用TortoiseSVN"></a>3.IDEA中使用TortoiseSVN</h2><h3 id="3-1-setting中配置svn"><a href="#3-1-setting中配置svn" class="headerlink" title="3.1 setting中配置svn"></a>3.1 setting中配置svn</h3><p><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/SVN21.png" alt></p><h3 id="3-2-svn在idea中的基本操作"><a href="#3-2-svn在idea中的基本操作" class="headerlink" title="3.2 svn在idea中的基本操作"></a>3.2 svn在idea中的基本操作</h3><h4 id="3-2-1-将项目checkout"><a href="#3-2-1-将项目checkout" class="headerlink" title="3.2.1 将项目checkout"></a>3.2.1 将项目checkout</h4><p><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/SVN22.png" alt></p><h4 id="3-2-2-按钮作用-update-commit-历史-返回版本"><a href="#3-2-2-按钮作用-update-commit-历史-返回版本" class="headerlink" title="3.2.2 按钮作用 update commit 历史 返回版本"></a>3.2.2 按钮作用 update commit 历史 返回版本</h4><p><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/SVN23.png" alt>    </p><h4 id="3-2-3-将项目提交到SVN"><a href="#3-2-3-将项目提交到SVN" class="headerlink" title="3.2.3 将项目提交到SVN"></a>3.2.3 将项目提交到SVN</h4><p><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/SVN24.png" alt></p><h4 id="3-2-4-忽略设置"><a href="#3-2-4-忽略设置" class="headerlink" title="3.2.4 忽略设置"></a>3.2.4 忽略设置</h4><p><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/SVN30.png" alt>    </p><h4 id="3-2-5-冲突解决"><a href="#3-2-5-冲突解决" class="headerlink" title="3.2.5 冲突解决"></a>3.2.5 冲突解决</h4><p><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/SVN31.png" alt><br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/SVN32.png" alt></p><h3 id="3-3-项目模版"><a href="#3-3-项目模版" class="headerlink" title="3.3 项目模版"></a>3.3 项目模版</h3><h4 id="3-3-1-建立模版项目"><a href="#3-3-1-建立模版项目" class="headerlink" title="3.3.1 建立模版项目"></a>3.3.1 建立模版项目</h4><p>branches：分支项目<br>tags：分支版本（一般设为只读）<br>trunk：项目主干<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/SVN34.png" alt>      </p><h4 id="3-3-2-创建分支"><a href="#3-3-2-创建分支" class="headerlink" title="3.3.2 创建分支"></a>3.3.2 创建分支</h4><p><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/SVN35.png" alt></p><h4 id="3-3-3-主干分支合并"><a href="#3-3-3-主干分支合并" class="headerlink" title="3.3.3 主干分支合并"></a>3.3.3 主干分支合并</h4><p><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/SVN37.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 版本控制系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目管理 </tag>
            
            <tag> 多人开发 </tag>
            
            <tag> 版本控制系统 </tag>
            
            <tag> 自由 </tag>
            
            <tag> 开源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle常见数据库对象</title>
      <link href="/2019/06/09/chang-jian-shu-ju-ku-dui-xiang/"/>
      <url>/2019/06/09/chang-jian-shu-ju-ku-dui-xiang/</url>
      
        <content type="html"><![CDATA[<h3 id="常见数据库对象"><a href="#常见数据库对象" class="headerlink" title="常见数据库对象"></a>常见数据库对象</h3><p><img src="https://ws1.sinaimg.cn/mw690/006lnyTwly1g70nm1tl69j30gl090aby.jpg" alt></p><h3 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h3><pre><code>自动提供唯一的数值          共享对象         主要用于提供主键值      代替应用代码        将序列值装入内存可以提高访问效率</code></pre><h4 id="创建序列"><a href="#创建序列" class="headerlink" title="创建序列"></a>创建序列</h4><pre><code>CREATE SEQUENCE dept_deptid_seq                INCREMENT BY 10 步长                START WITH 120 起始位置                MAXVALUE 9999 最大值                NOCYCLE 无循环                NOCACHE 无缓存                    ; </code></pre><h4 id="查询序列"><a href="#查询序列" class="headerlink" title="查询序列"></a>查询序列</h4><pre><code>查询数据字典视图 USER_SEQUENCES获取序列定义信息SELECT    sequence_name, min_value, max_value,     increment_by, last_numberFROM    user_sequences;如果指定NOCACHE 选项，则列LAST_NUMBER 显示序列中下一个有效的值</code></pre><h4 id="NEXTVAL-和-CURRVAL伪列"><a href="#NEXTVAL-和-CURRVAL伪列" class="headerlink" title="NEXTVAL 和 CURRVAL伪列"></a>NEXTVAL 和 CURRVAL伪列</h4><p>NEXTVAL 返回序列中下一个有效的值，任何用户都可以引用<br>CURRVAL 中存放序列的当前值<br>NEXTVAL 应在 CURRVAL 之前指定 ，二者应同时有效              </p><pre><code>INSERT INTO departmentsVALUES(departments_seq.NEXTVAL,&#39;abc&#39;,NULL,NULL)SELECT * FROM departments;</code></pre><h4 id="使用序列"><a href="#使用序列" class="headerlink" title="使用序列"></a>使用序列</h4><pre><code>将序列值装入内存可提高访问效率序列在下列情况下出现裂缝:回滚系统异常多个表同时使用同一序列如果不将序列的值装入内存(NOCACHE), 可使用表 USER_SEQUENCES 查看序列中下一个有效值</code></pre><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><pre><code>索引:一种数据库对象通过指针加速 Oracle 服务器的查询速度通过快速定位数据的方法，减少磁盘 I/O索引与表相互独立Oracle 服务器自动使用和维护索引</code></pre><h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><p><strong>自动创建</strong>: 在定义 PRIMARY KEY 或 UNIQUE 约束后系统自动在相应的列上创建唯一性索引<br><strong>手动创建</strong>: 用户可以在其它列上创建非唯一的索引，以加速查询</p><pre><code>CREATE INDEX     emp_last_name_idxON         employees(last_name);</code></pre><h4 id="什么时候创建索引"><a href="#什么时候创建索引" class="headerlink" title="什么时候创建索引"></a>什么时候创建索引</h4><pre><code>以下情况可以创建索引:列中数据值分布范围很广列中包含大量空值列经常在 WHERE 子句或连接条件中出现表经常被访问而且数据量很大 ，访问的数据大概占数据总量的2%到4%</code></pre><h4 id="什么时候不要创建索引"><a href="#什么时候不要创建索引" class="headerlink" title="什么时候不要创建索引"></a>什么时候不要创建索引</h4><pre><code>下列情况不要创建索引:表很小列不经常作为连接条件出现在WHERE子句中查询的数据大于2%到4%表经常更新加索引的列包含在表达式中</code></pre><h4 id="查询索引"><a href="#查询索引" class="headerlink" title="查询索引"></a>查询索引</h4><pre><code>SELECT    ic.index_name, ic.column_name,    ic.column_position col_pos,ix.uniquenessFROM    user_indexes ix, user_ind_columns icWHERE    ic.index_name = ix.index_nameAND    ic.table_name = &#39;EMPLOYEES&#39;;</code></pre><h3 id="同义词"><a href="#同义词" class="headerlink" title="同义词"></a>同义词</h3><pre><code>使用同义词访问相同的对象:方便访问其它用户的对象缩短对象名字的长度CREATE [PUBLIC] SYNONYM synonymFOR    object;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle组函数</title>
      <link href="/2019/06/08/zu-han-shu/"/>
      <url>/2019/06/08/zu-han-shu/</url>
      
        <content type="html"><![CDATA[<h3 id="组函数概念"><a href="#组函数概念" class="headerlink" title="组函数概念"></a>组函数概念</h3><p>组函数作用于一组数据并对一组数据返回一个值<br>忽略空值元素<br>AVG COUNT MAX MIN SUM<br>不能再WHERE子句使用组函数</p><p><img src="https://ws1.sinaimg.cn/mw690/006lnyTwly1g70nxt5jetj30by071weq.jpg" alt></p><pre><code>组函数语法SELECT    [column,] group_function(column), ...FROM        table[WHERE    condition][GROUP BY    column][ORDER BY    column];</code></pre><h3 id="AVG（平均值）和-SUM-（合计）函数"><a href="#AVG（平均值）和-SUM-（合计）函数" class="headerlink" title="AVG（平均值）和 SUM （合计）函数"></a>AVG（平均值）和 SUM （合计）函数</h3><p>可以对数值型数据使用AVG 和 SUM 函数。</p><pre><code>SELECT AVG(salary), MAX(salary)FROM   employeesWHERE  job_id LIKE &#39;%REP%&#39;;</code></pre><h3 id="MIN（最小值）-和-MAX（最大值）函数"><a href="#MIN（最小值）-和-MAX（最大值）函数" class="headerlink" title="MIN（最小值） 和 MAX（最大值）函数"></a>MIN（最小值） 和 MAX（最大值）函数</h3><p>可以对任意数据类型的数据使用 MIN 和 MAX 函数。</p><pre><code>SELECT MIN(hire_date), MAX(hire_date)FROM      employees;</code></pre><h3 id="COUNT（计数）函数"><a href="#COUNT（计数）函数" class="headerlink" title="COUNT（计数）函数"></a>COUNT（计数）函数</h3><pre><code>COUNT(*) 返回表中记录总数。SELECT COUNT(*)FROM      employeesWHERE  department_id = 50;</code></pre><pre><code>COUNT(expr) 返回 expr不为空的记录总数。SELECT COUNT(commission_pct)FROM   employeesWHERE  department_id = 80;</code></pre><h3 id="组函数忽略空值元素"><a href="#组函数忽略空值元素" class="headerlink" title="组函数忽略空值元素"></a>组函数忽略空值元素</h3><pre><code>SELECT COUNT(commission_pct),AVG(commission_pct),AVG(NVL(commission_pct,0)FROM employees;</code></pre><h3 id="DISTINCT-关键字"><a href="#DISTINCT-关键字" class="headerlink" title="DISTINCT 关键字"></a>DISTINCT 关键字</h3><p>COUNT(DISTINCT expr) 返回 expr非空且不重复的记录总数</p><pre><code>SELECT AVG(salary),AVG(DISTINCT salary),SUM(salary),SUM(DISTINCT salary)FROM employees;</code></pre><h3 id="GROUP-BY子句"><a href="#GROUP-BY子句" class="headerlink" title="GROUP BY子句"></a>GROUP BY子句</h3><ol><li>可以使用GROUP BY子句将表中的数据分成若干组             </li><li>在SELECT列表中所有未包含在组函数中的列都应该包含在GROUP BY子句中<pre><code>GROUP BY 子句语法SELECT    column, group_function(column)FROM        table[WHERE    condition][GROUP BY    group_by_expression][ORDER BY    column];==============================================在GROUP BY子句中包含多个列SELECT   department_id dept_id, job_id, SUM(salary)FROM     employeesGROUP BY department_id, job_id ;</code></pre></li></ol><pre><code>### HAVING 子句一般写组函数过滤          SQL文的执行顺序：           FROM--&gt;WHERE--&gt;GROUP BY--&gt;HAVING--&gt;SELECT--&gt;ORDER BY        WHERE子句是在数据分组前进行过滤；HAVING子句是在数据分组后进行过滤。           要把WHERE子句中的过滤条件写在HAVING子句中。</code></pre><p>SELECT   job_id, SUM(salary) PAYROLL<br>FROM     employees<br>WHERE    job_id NOT LIKE ‘%REP%’<br>GROUP BY job_id<br>HAVING   SUM(salary) &gt; 13000<br>ORDER BY SUM(salary);</p><pre><code>注意：不要把WHERE子句中的过滤条件写在HAVING子句中 ### 嵌套组函数使用嵌套函数时，最多只能嵌套两层，同时不能使用没有包涵在组函数中的列</code></pre><p>SELECT   MAX(AVG(salary))<br>FROM     employees<br>GROUP BY department_id;</p><pre><code></code></pre>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle操作数据</title>
      <link href="/2019/06/07/cao-zuo-shu-ju/"/>
      <url>/2019/06/07/cao-zuo-shu-ju/</url>
      
        <content type="html"><![CDATA[<h3 id="SQL语句的分类"><a href="#SQL语句的分类" class="headerlink" title="SQL语句的分类"></a>SQL语句的分类</h3><pre><code>            DQL：数据查询语言                          DML：数据操作语言                      DDL：数据定义语言                      DCL：数据控制语言                    TVL：事务控制语言</code></pre><p><img src="https://ws1.sinaimg.cn/mw690/006lnyTwly1g70nwz929gj30g2084q2v.jpg" alt></p><h3 id="插入语句-INSERT"><a href="#插入语句-INSERT" class="headerlink" title="插入语句 INSERT"></a>插入语句 INSERT</h3><p>INSERT 一次只能向表中插入一条数据 </p><pre><code>INSERT INTO departments(department_id,department_name,manager_id,location_id)VALUE (70,&#39;public Relations&#39;,100,1700)</code></pre><p>指定列名时，值的顺序一定要跟列的顺序一致<br>不指定列名时，值的顺序要和表中的顺序一致      </p><pre><code>INSERT INTO departmentsVALUES (72,&#39;public Relations&#39;,100,1700)</code></pre><p>可以往列中插入默认值，注意：必须保证该列允许空值</p><pre><code>INSERT INTO departmentsVALUES (74,&#39;Public Relatios&#39;,DEFAULT,DEFAULT);</code></pre><p>在插入时，如果指定列名，则一定要把所有非空列列举出来</p><p>当把记录插入到表中时，新的记录在表中的位置是不固定的。插入的记录在表中是无序的。</p><p>在插入记录时，注意不要主键约束，外键约束等五个约束</p><pre><code>从其他表中拷贝数据在 INSERT 语句中加入子查询。INSERT INTO copy_emp  SELECT *  FROM   employees  WHERE  job_id LIKE &#39;%REP%&#39;;不必书写 VALUES 子句。 子查询中的值列表的个数与数据类型应与 INSERT 子句中的列的个数和数据类型对应。</code></pre><p>将查询语句结果一次性插入到表中，要求表的结构与查询结果的结构一致</p><pre><code>INSERT IMTO copySELECT * FROM employees</code></pre><h3 id="更新数据-UPDATE"><a href="#更新数据-UPDATE" class="headerlink" title="更新数据 UPDATE"></a>更新数据 UPDATE</h3><pre><code>语法UPDATE table SET column = value [,column=value,...][WHERE condition]</code></pre><p>使用where子句制定需要更新的数据</p><pre><code>UPDATE employeesSET department_id = 70 WHERE employee_id=113;</code></pre><p>注意：在使用UPDATE语句时，一定要加上WHERE子句</p><p>如果省略WHERE子句，则表中的所有数据都将被更新</p><pre><code>UPDATE     copy_empSET        department_id = 110;</code></pre><p>在UPDATE语句中也可以使用子查询</p><pre><code>UPDATE  copy_empSET     department_id  =  (SELECT department_id                           FROM employees                           WHERE employee_id = 100)WHERE   job_id         =  (SELECT job_id                           FROM employees                           WHERE employee_id = 200);</code></pre><h3 id="删除数据-DELETE"><a href="#删除数据-DELETE" class="headerlink" title="删除数据  DELETE"></a>删除数据  DELETE</h3><pre><code>DELETE [FROM]      table[WHERE      condition];</code></pre><p>使用where子句删除指定记录  </p><pre><code class="math">DELETE FROM departments WHERE  department_name = &#39;Finance&#39;;</code></pre><p>省略where子句则删除整表   </p><pre><code>DELETE FROM  copy_emp;</code></pre><p>删除数据注意完整性错误               不能删除正在被其他表使用的记录               </p><h3 id="显式默认值概述"><a href="#显式默认值概述" class="headerlink" title="显式默认值概述"></a>显式默认值概述</h3><pre><code>使用 DEFAULT 关键字表示默认值符合SQL:1999标准可以使用显示默认值控制默认值的使用显示默认值可以在 INSERT 和 UPDATE 语句中使用</code></pre><p>在插入操作中使用默认值:</p><pre><code>INSERT INTO departments  (department_id, department_name, manager_id) VALUES (300, &#39;Engineering&#39;, DEFAULT);</code></pre><h3 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h3><p>事务是由完成若干工作的DML语句组成的逻辑单位              </p><p><strong>事务的四个特性</strong>：ACID<br>            原子性(A)不可分割<br>            一致性(C)事物开始前和结束后看到的都是一样的<br>            隔离性(I)在事务进行中其他人是看不到的<br>            永久性(D)事务结束后数据永远保存在数据库里面    </p><p><strong>数据库事务</strong>        </p><p>一个或多个DML操作<br>一个DDL定义<br>一个DCL空值            </p><pre><code>以第一个DML语句的执行作为开始  以下面其中之一作为结束           显示的COMMIT 或 ROLLBACK 语句            DDL 或 DCL 语句（自动提交）          用户退出iSQL*PLUS，会话正常结束         系统异常终了</code></pre><p><strong>COMMIT和ROLLBACK语句的优点</strong></p><pre><code>事务结束时要么执行commit 要么执行rollback确保数据的完整性在数据改变被提交之前重新检查我们所改变的数据是否正确将逻辑相关的操作分组</code></pre><p><strong>隐式事务进程</strong></p><p>自动提交自动回滚的过程</p><pre><code>自动提交在以下情况中执行:DDL 语句。DCL 语句。不使用 COMMIT 或 ROLLBACK 语句提交或回滚，正常结束会话。会话异常结束或系统异常会导致自动回滚。</code></pre><p><strong>提交后的数据状态</strong></p><pre><code>数据的改变已经被保存到数据库中。改变前的数据已经丢失。所有用户可以看到结果。锁被释放， 其他用户可以操作涉及到的数据。所有保存点被释放。</code></pre><h4 id="读一致性"><a href="#读一致性" class="headerlink" title="读一致性"></a>读一致性</h4><pre><code>读一致性保证在任何时间任何用户所看到的数据都是一致的。一个用户的对数据的改变不会影响其他用户的改变。对于相同的数据读一致性保证:查询不等待修改。修改不等待查询。</code></pre><h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><p>独占锁: 屏蔽其他用户。<br>共享锁: 允许其他用户操作。</p><p>DML：表共享，行独占</p>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>git搭建与基本操作</title>
      <link href="/2019/06/07/git-da-jian-yu-ji-ben-cao-zuo/"/>
      <url>/2019/06/07/git-da-jian-yu-ji-ben-cao-zuo/</url>
      
        <content type="html"><![CDATA[<h2 id="Git理论"><a href="#Git理论" class="headerlink" title="Git理论"></a>Git理论</h2><h3 id="1-1git的概述"><a href="#1-1git的概述" class="headerlink" title="1,1git的概述"></a>1,1git的概述</h3><p>git是一个开源的分布式版本控制系统，可以借助github托管项目代码，进行团队开发。</p><h3 id="1-2git网址"><a href="#1-2git网址" class="headerlink" title="1.2git网址"></a>1.2git网址</h3><p>国内码云<br>国外github</p><h3 id="1-3-Git原理图"><a href="#1-3-Git原理图" class="headerlink" title="1.3 Git原理图"></a>1.3 Git原理图</h3><p><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/git18.png" alt></p><h2 id="Git实战"><a href="#Git实战" class="headerlink" title="Git实战"></a>Git实战</h2><p>使用前要安装git，并配置环境变量。</p><h3 id="2-1工作时开发的注意事项"><a href="#2-1工作时开发的注意事项" class="headerlink" title="2.1工作时开发的注意事项"></a>2.1工作时开发的注意事项</h3><p>1.代码需要备份各个版本都要备份【1.0版本出现问题，不能在2.0版本上修复】<br>2.上班下载代码，下班上传代码。<br>3.解决工作中团队开发的代码冲突问题。</p><h3 id="2-2在idea中使用Git"><a href="#2-2在idea中使用Git" class="headerlink" title="2.2在idea中使用Git"></a>2.2在idea中使用Git</h3><h4 id="2-2-1配置git"><a href="#2-2-1配置git" class="headerlink" title="2.2.1配置git"></a>2.2.1配置git</h4><p><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/git01.png" alt></p><h4 id="2-2-2搭建项目"><a href="#2-2-2搭建项目" class="headerlink" title="2.2.2搭建项目"></a>2.2.2搭建项目</h4><p>1.在码云上创建仓库<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/git02.png" alt><br>2.idea中新建项目，项目名要和码云上的一致。<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/git03.png" alt><br>3.将本地项目上传到码云上<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/git04.png" alt><br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/git05.png" alt><br>4.将本地项目删除通过码云上的ssh克隆一个项目到本地<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/git06.png" alt></p><h4 id="2-2-3项目上传"><a href="#2-2-3项目上传" class="headerlink" title="2.2.3项目上传"></a>2.2.3项目上传</h4><p>1.修改项目里的内容通过commit上传到本地的master<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/git07.png" alt><br>CommitMessage里面写修改的内容<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/git08.png" alt></p><hr><p>2.通过Push上传的git仓库<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/git09.png" alt><br>添加成功<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/git10.png" alt></p><h4 id="2-2-4版本操作管理"><a href="#2-2-4版本操作管理" class="headerlink" title="2.2.4版本操作管理"></a>2.2.4版本操作管理</h4><p>1.通过Branchers新建个版本分支<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/git11.png" alt></p><ol start="2"><li>1.0为新建的版本分支 master为主分支 check out是切换到该版本<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/git12.png" alt></li><li>登入码云看到分支添加成功<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/git13.png" alt></li><li>合并版本使用Merage<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/git14.png" alt><br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/git15.png" alt></li></ol><h4 id="2-2-5历史记录"><a href="#2-2-5历史记录" class="headerlink" title="2.2.5历史记录"></a>2.2.5历史记录</h4><p>1.使用Compare with 进行版本间的比较<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/git16.png" alt></p><p>2.历史记录按钮可看到项目或文件的历史修改信息<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/git19.png" alt><br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/git17.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 版本控制系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式版本控制系统 </tag>
            
            <tag> git </tag>
            
            <tag> 项目管理 </tag>
            
            <tag> 多人开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle视图</title>
      <link href="/2019/06/06/shi-tu/"/>
      <url>/2019/06/06/shi-tu/</url>
      
        <content type="html"><![CDATA[<p>视图实际上是保存一条查询语句<br>视图的用法与表的用法一样</p><h3 id="使用视图的好处"><a href="#使用视图的好处" class="headerlink" title="使用视图的好处"></a>使用视图的好处</h3><p>限制数据访问<br>简化查询<br>提供数据独立性<br>给相同的数据提供不同的数据表象                 </p><h3 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h3><p>CREATE VIEW </p><pre><code>CREATE VIEW     empvu80 AS SELECT  employee_id, last_name, salary    FROM    employees    WHERE   department_id = 80;</code></pre><p>可以针对视图进行增删改操作，但最终会影响到表中的数据。有些情况下不能对视图进行增删改</p><h3 id="简单视图和复杂视图"><a href="#简单视图和复杂视图" class="headerlink" title="简单视图和复杂视图"></a>简单视图和复杂视图</h3><p><img src="https://ws1.sinaimg.cn/mw690/006lnyTwly1g70nijgueqj30is07t74j.jpg" alt></p><p>创建复杂视图</p><pre><code>CREATE VIEW    dept_sum_vu  (name, minsal, maxsal, avgsal)AS SELECT     d.department_name, MIN(e.salary),              MAX(e.salary),AVG(e.salary)   FROM      employees e, departments d   WHERE     e.department_id = d.department_id    GROUP BY  d.department_name;</code></pre><h3 id="TOP-N分析"><a href="#TOP-N分析" class="headerlink" title="TOP-N分析"></a>TOP-N分析</h3><p>ROWNUM伪列：用于生成记录的序号从1开始     </p><pre><code>SELECT ROWNUM,employee_id,last_naem,salaryFFROM employeesORDER BY salary DESC</code></pre><p>ROWNUM 伪列时在执行完FROM子句之后，在执行WHERE子句之前给每条记录加一个序号</p><p>在使用ROWNUM伪列前一定要保证数据是有序排列</p><p>– 在使用ROWNUM伪列时一定要包含序号为1的记录，否则无查询结果 </p>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>搭建HEXO</title>
      <link href="/2019/06/05/da-jian-hexo/"/>
      <url>/2019/06/05/da-jian-hexo/</url>
      
        <content type="html"><![CDATA[<h2 id="认识-Hexo"><a href="#认识-Hexo" class="headerlink" title="认识 Hexo"></a>认识 Hexo</h2><p>hexo是一个快速，简洁高效的博客框架。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>1.node：用来生成静态页面的 到Node.js官网下载相应平台的最新版本。<br>2.git: 把本地的hexo内容提交到github上去。<br>3.github：用来做博客的远程创库、域名、服务器。</p><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>当Node.js和Git都安装好后就可以正式安装Hexo了，终端执行如下命令：</p><blockquote><p>$ sudo npm install -g hexo</p></blockquote><p>输入管理员密码即开始安装</p><blockquote><p>Hexo官网上的安装命令是$ npm install -g hexo-cli，安装时不要忘记前面加上sudo，否则会因为权限问题报错。<br>初始化</p></blockquote><p>终端cd到一个你选定的目录（比如创建一个blog文件，$cd blog），执行hexo init命令：</p><blockquote><p>$ hexo init</p></blockquote><p>在blog目录下，执行如下命令，安装npm：</p><blockquote><p>$ npm install</p></blockquote><p>执行如下命令，开启hexo服务器：</p><blockquote><p>$ hexo s</p></blockquote><p>此时，浏览器中打开网址<a href="http://localhost:4000，能看到如下页面：" target="_blank" rel="noopener">http://localhost:4000，能看到如下页面：</a><br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/hexo01.png" alt="hexo01"></p><h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><p>登录Github账号，新建仓库，名为用户名.github.io固定写法。<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/hexo02.png" alt="hexo02"></p><p>找到blog文件夹下的_config.yml文件找到最后一行修改为（更多yml部署查阅Hexo文档） </p><blockquote><p>deploy:<br>    type: git<br>    repository: <a href="https://github.com/edderqin/edderqin.github.io.git" target="_blank" rel="noopener">https://github.com/edderqin/edderqin.github.io.git</a><br>    branch: master</p></blockquote><p>注意：在配置所有的_config.yml文件时（包括theme中的），在所有的冒号:后边都要加一个空格，否则执行hexo命令会报错，切记 切记</p><p>在blog文件夹目录下执行生成静态页面命令：</p><blockquote><p>$ hexo generate        或者：hexo g</p></blockquote><p>再执行配置命令：</p><blockquote><p>$ hexo deploy            或者：hexo d</p></blockquote><p>注意：若执行命令hexo deploy仍然报错：无法连接git或找不到git，则执行如下命令来安装hexo-deployer-git：<br>$ npm install hexo-deployer-git –save<br>若你未关联Github，则执行hexo deploy命令时终端会提示你输入Github的用户名和密码<br>hexo deploy命令执行成功后，浏览器中打开网址<a href="http://edderqin.github.io（将edderqin换成你的用户名）能看到和打开http://localhost:4000时一样的页面。" target="_blank" rel="noopener">http://edderqin.github.io（将edderqin换成你的用户名）能看到和打开http://localhost:4000时一样的页面。</a>　</p><h2 id="添加ssh-key到Github"><a href="#添加ssh-key到Github" class="headerlink" title="添加ssh key到Github"></a>添加ssh key到Github</h2><p>1.1检查SSH keys是否存在Github<br>执行如下命令，检查SSH keys是否存在。如果有文件id_rsa.pub或id_dsa.pub，则直接进入步骤1.3将SSH key添加到Github中，否则进入下一步生成SSH key。</p><blockquote><p>$ ls -al ~/.ssh</p></blockquote><p>1.2.生成新的ssh key<br>执行如下命令生成public/private rsa key pair，注意将<a href="mailto:your_email@example.com" target="_blank" rel="noopener">your_email@example.com</a>换成你自己注册Github的邮箱地址。</p><blockquote><p>$ ssh-keygen -t rsa -C “<a href="mailto:your_email@example.com" target="_blank" rel="noopener">your_email@example.com</a>“默认会在相应路径下C盘用户目录下（~/.ssh/id_rsa.pub）生成id_rsa和id_rsa.pub两个文件</p></blockquote><p>1.3.将ssh key添加到Github中<br>Find前往文件夹~/.ssh/id_rsa.pub打开id_rsa.pub文件，里面的信息即为SSH key，将这些信息复制到Github的Add SSH key页面即可。<br>进入Github –&gt; Settings –&gt; SSH keys –&gt; add SSH key:<br>Title里任意添一个标题，将复制的内容粘贴到Key里，点击下方Add key绿色按钮即可。<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/hexo03.png" alt="hexo03"></p><h2 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h2><p>终端cd到blog文件夹下，执行如下命令新建文章：</p><blockquote><p>hexo new “postName”</p></blockquote><p>名为postName.md的文件会建在目录/blog/source/_posts下。<br>文章编辑完成后，终端cd到blog文件夹下，执行如下命令来发布: </p><blockquote><p>hexo g             //生成静态页面<br>hexo d            //将文章部署到Github</p></blockquote><h2 id="安装theme"><a href="#安装theme" class="headerlink" title="安装theme"></a>安装theme</h2><p>你可以到Hexo官网主题页去搜寻自己喜欢的theme。这里以hexo-theme-next为例<br>终端cd到 blog 目录下执行如下命令：</p><blockquote><p>$ git clone <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next</a> themes/next</p></blockquote><p>将blog目录下_config.yml里theme的名称landscape修改为next<br>终端cd到blog目录下执行如下命令(每次部署文章的步骤)：</p><blockquote><p>$ hexo clean           //清除缓存文件 (db.json) 和已生成的静态文件 (public)<br>$ hexo g             //生成缓存和静态文件<br>$ hexo d             //重新部署到服务器</p></blockquote><p>至于更改theme内容，比如名称，描述，头像等去修改blog/_config.yml文件和blog/themes/next/_config.yml文件中对应的属性名称即可，不要忘记冒号:后加空格。NexT 使用文档里有极详细的介绍。</p><h2 id="绑定个人域名"><a href="#绑定个人域名" class="headerlink" title="绑定个人域名"></a>绑定个人域名</h2><p>首先要有一个域名我的域名是在阿里云买的<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/hexo04.png" alt="hexo04"></p><p>审核通过后进行解析<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/hexo06.png" alt="hexo06"><br>添加三条解析 后两条固定为，192.30.252.153和192.30.252.154这两个IP地址为github的服务器地址 CNAME记录值填你的github博客网址<br>这些全部设置完成后，此时你并不能要申请的域名访问你的博客。接着你需要做的是在hexo根目录的source文件夹里创建CNAME文件，不带任何后缀，里面添加你的域名信息 如 edderblog.top<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/hexo07.png" alt="hexo07"><br>接下来输入域名即可访问项目</p><p>参考资料:<br><a href="https://www.cnblogs.com/penglei-it/p/hexo_domain_name.html" target="_blank" rel="noopener">https://www.cnblogs.com/penglei-it/p/hexo_domain_name.html</a> hexo域名配置<br><a href="https://www.cnblogs.com/MuYunyun/p/5927491.html" target="_blank" rel="noopener">https://www.cnblogs.com/MuYunyun/p/5927491.html</a> 建站参考<br><a href="https://www.cnblogs.com/fengxiongZz/p/7707219.html" target="_blank" rel="noopener">https://www.cnblogs.com/fengxiongZz/p/7707219.html</a> 建站详细资料<br><a href="https://easyhexo.com/https://easyhexo.com/" target="_blank" rel="noopener">https://easyhexo.com/https://easyhexo.com/</a> eazy hexo</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> hexo </tag>
            
            <tag> 搭建博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/06/04/hello-world/"/>
      <url>/2019/06/04/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
