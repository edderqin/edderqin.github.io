<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>操作系统复习题（大题）</title>
      <link href="/2019/06/27/cao-zuo-xi-tong-fu-xi-ti/"/>
      <url>/2019/06/27/cao-zuo-xi-tong-fu-xi-ti/</url>
      
        <content type="html"><![CDATA[<h3 id="1-pv操作"><a href="#1-pv操作" class="headerlink" title="1.pv操作"></a>1.pv操作</h3><p>p：申请资源<br>v：释放资源</p><h4 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h4><p>信号量是一个int型的变量<br>当信号量大于零时表示当前系统中某类资源的个数<br>当信号量小于零时表示当前系统中等待某类资源的个数    </p><pre><code>假定一个阅览室最多可容纳100人，读者进入和离开阅览室时都必须在门口的一个登记表进行登记，而且每次只允许一个进行登记操作，请用P、V操作实现并发的读者进程间的同步问题。</code></pre><p>先找临界资源<br>临界资源：<br>1.座位：s=100<br>2.登记表：m=1<br>注意pv操作成对出现</p><p>解：<br>s=100<br>m=1<br>void main{<br>&emsp;    cobegin<br>&emsp;&emsp;    readeri(i=1,2,3….n)<br>&emsp;coend<br>}</p><p>readeri(){<br>&emsp;    p(s);<br>&emsp;&emsp;        p(m);<br>&emsp;&emsp;阅览室有空位置找登记表进行登记<br>&emsp;&emsp;        v(m);<br>&emsp;&emsp;放回登记表学习<br>&emsp;&emsp;        p(m);<br>&emsp;&emsp;找出登记项删除登记<br>&emsp;&emsp;        v(m);<br>&emsp;&emsp;走出阅览室<br>&emsp;    V(s);        </p><p>}</p><h3 id="2-作业调度、进程调度、内存分配和设备分配"><a href="#2-作业调度、进程调度、内存分配和设备分配" class="headerlink" title="2.作业调度、进程调度、内存分配和设备分配"></a>2.作业调度、进程调度、内存分配和设备分配</h3><p><a href="https://blog.csdn.net/HaoDaWang/article/details/78598178" target="_blank" rel="noopener">作业调度的五种算法</a><br>某系统采用不能移动已在主存中作业的可变分区方式管理主存，现在有供用户使用的主存空间100K，系统配有4台磁带机，现有一作业序列：<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/os01.png" alt><br>该系统采用多道程序设计技术，对磁带机采用静态分配，请分别写出采用先来先服务和短作业优先算法选中作业执行的次序和平均周转时间。    </p><p>根据题意，我们需要先分析出各种算法的运行情况。<br>(1) 先来先服务算法的运行情况<br>先来先服务的运行情况            </p><table><thead><tr><th>序号</th><th>提交时间</th><th>进入主存时间</th><th>开始计算时间</th><th>结束计算时间</th><th>周转时间</th></tr></thead><tbody><tr><td>1</td><td>10:00</td><td>10:00</td><td>10:00</td><td>10:25</td><td>25</td></tr><tr><td>2</td><td>10:20</td><td>10:20</td><td>10:25</td><td>10:55</td><td>35</td></tr><tr><td>3</td><td>10:35</td><td>10:35</td><td>10:50</td><td>11:15</td><td>40</td></tr><tr><td>4</td><td>10:40</td><td>10:55</td><td>11:15</td><td>11:30</td><td>50</td></tr><tr><td>5</td><td>10:30</td><td>11:30</td><td>11:30</td><td>11:40</td><td>70</td></tr><tr><td>所以，平均周转时间为：(25+35+40+50+70)/5=44min。</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>(2) 按计算时间最短者优先算法。<br>序号 | 提交时间 | 进入主存时间 | 开始计算时间 | 结束计算时间 | 周转时间<br>—|—|—|—|—|—<br>1 | 10:00 | 10:00 | 10:00 | 10:25 | 25<br>2 | 10:20 | 10:20 | 10:25 | 10:55 | 35<br>3 | 10:35 | 10:35 | 11:10 | 11:30 | 55<br>4 | 10:40 | 10:55 | 10:55 | 11:10 | 30<br>5 | 10:30 | 11:30 | 11:30 | 11:40 | 70<br>所以，平均周转时间为：(25+35+30+55+70)/5=43min。</p><h3 id="3-银行家算法"><a href="#3-银行家算法" class="headerlink" title="3.银行家算法"></a>3.银行家算法</h3><p>假定系统中有五个进程{P0, P1, P2, P3, P4}和三类资源{A, B, C}，各种资源的数量分别为10、5、7，在T0时刻的资源分配情况如图所示。<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/os02.png" alt></p><p>(1) T0时刻是否安全状态？若是，请给出安全序列。<br>(2)在T0时刻若进程P1请求资源（1，0，2），是否能实施资源分配？为什么？<br>(3)在（2）的基础上，若进程P4请求资源（3，3，0），是否能实施资源分配？为什么？<br>(4)在（3）的基础上，若进程P0请求资源 （0，2，0），是否能实施资源分配？为什么？           </p><p>①安全序列为{P1, P3, P4, P2, P0}<br>②能实施资源分配Request1(1, 0, 2)≤Need1(1, 2, 2) &emsp; Request1(1, 0, 2)≤Available(3, 3, 2) &emsp;<br>&emsp;假定可为P1分配资源，利用安全性算法检查，存在安全序列为{P1, P3, P4, P0 P2}<br>③P4发出请求向量Request4(3，3，0)，系统按银行家算法进行检查：<br> Request4(3，3，0)≤Need4(4，3，1)；Request4(3，3，0)＞Available(2，3，0)，则不能实施资源分配，让P4等待。<br> ④P0发出请求向量Request0(0，2，0)，系统按银行家算法进行检查： Request0(0，2，0)≤Need0(7，4，3)；Request0(0，2，0)≤Available(2，3，0)； 先假定可为P0分配资源，利用安全性算法检查，不存在安全序列 ，</p><h3 id="4-页面置换算法"><a href="#4-页面置换算法" class="headerlink" title="4.页面置换算法"></a>4.页面置换算法</h3><h4 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h4><p>在一个请求分页存储管理系统中，一个作业的页面走向为4、3、2、1、4、3、5、4、3、2、1、5，当分配给该作业的物理块数分别为3时，试计算采用下述页面淘汰算法时的缺页率（假设开始执行时主存中没有页面），并比较所得结果。          </p><pre><code>最佳置换淘汰算法（OPT）。          先进先出淘汰算法（FIFO）。         最近最久未使用淘汰算法(LRU)。</code></pre><p><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/os03.png" alt><br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/os04.png" alt><br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/os05.png" alt></p><h4 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h4><p>某页式虚存储系统的物理空间共3KB，页面大小为1KB。一进程按下列地址顺序引用内存单元：3635、3632、1140、3584、2892、3640、0040、2148、1700、2145、3209、0000、1102、1100。如果上述数字均为十进制数，而内存中尚未装入任何页。给出使用LRU算法是的缺页次数，并与FIFO是的情况进行比较。<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/os06.png" alt></p><h4 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h4><p>某采用页式存储管理的系统中，接收了一个作业，作业执行时依次访问的页为：1，2，3，4，2，1，5，6，2，1，2，3，7。系统在主存中分配给该作业4个物理快，若开始四页已先装入主存（即作业执行前已将1、2、3、4页调入内存中，1页最先进入内存，4页最后装入内存）</p><pre><code>试分别计算采用FIFO、LRU和OPT算法时，作业执行过程中会产生多少次缺页中断 、缺页率并写出依次产生缺页中断后应淘汰的页</code></pre><p>采用先进先出调度算法会产生6次缺页中断，依次淘汰的页是1、2、3、4、5、6.<br>采用最近最少用调度算法会产生4次缺页中断，依次淘汰的页是3、4、5、6.</p><h4 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h4><p>设某分页系统中，页面大小为100字节，一个程序大小为1200字节，逻辑地址访问序列如下：10，205，110，735，603，50，815，314，432，320，225，80，130，270。系统为其分配4个主存块。</p><pre><code>试用LRU、OPT和FIFO算法算出各个页面置换算法的命中率</code></pre><p><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/os07.png" alt><br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/os08.png" alt></p><h3 id="5-地址转换"><a href="#5-地址转换" class="headerlink" title="5.地址转换"></a>5.地址转换</h3><h4 id="1-1"><a href="#1-1" class="headerlink" title="1."></a>1.</h4><p>在一分页存储管理系统中，逻辑地址长度为16位，页面大小为4096B，现有一逻辑地址为2F6AH，且第0、1、2页依次存放在物理块5、10、11中，问相应的物理地址为多少？       </p><p> 答：页号：4位 ，页内偏移地址：12位<br>        2F6AH=（0010   111101101010）<br>      页号2 存在第11块中（1011   111101101010）<br>   物理地址：BF6AH</p><h4 id="2-1"><a href="#2-1" class="headerlink" title="2."></a>2.</h4><p>设有一页式存储管理系统，向用户提供的逻辑地址空间最大为16页，每页2048B，内存总共有8个存储块，试问逻辑地址至少应为多少位？内存空间有多大？</p><p>  答：211=2048    24=16 ，所以逻辑地址至少15位。<br>内存空间：8*2048=16K    </p><h3 id="6-磁盘调度算法"><a href="#6-磁盘调度算法" class="headerlink" title="6.磁盘调度算法"></a>6.磁盘调度算法</h3><p>若磁头的当前位置为100磁道，磁头正向磁道增加方向移动。现有一磁盘读写请求队列：23，376，205，132，19，61，190，398，29，4，18，40。若采用先来先服务、最短寻道时间优先和扫描算法：<br>试计算出平均寻道长度各为多少？<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/os09.png" alt></p><h3 id="7-物理块优化"><a href="#7-物理块优化" class="headerlink" title="7.物理块优化"></a>7.物理块优化</h3><h4 id="1-2"><a href="#1-2" class="headerlink" title="1."></a>1.</h4><p>假定磁盘转速为20ms/r，磁盘格式化时每个磁道被划分为10个扇区，今有10个逻辑记录（每个记录的大型刚好与扇区大小相等）存放在同一磁道上，处理程序每次从磁盘读出一个记录后要花4ms进行处理，现要求顺序处理这10个记录，若磁头现在正处于首个逻辑记录的始点位置。<br>请问：<br>按逆时针方向安排10个逻辑记录（磁盘顺时针方向转），处理程序处理完这10个记录所需要的时间是多少<br>按最优化分布重新安排这10个逻辑记录，写出记录的安排，并计算出所需要处理的时间     </p><p><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/os10.png" alt></p><h4 id="2-2"><a href="#2-2" class="headerlink" title="2."></a>2.</h4><p>如果磁盘的每个磁道分成9个块，现有一个文件共有  A，B，…，I         9个记录，每个记录的大小与块的大小相等，设磁盘转速为27ms/r，每读出一块后需要2ms的处理时间。若忽略其他辅助时间，试问<br>如果顺序存放这些记录并顺序读取，处理该文件要多少时间？<br>如果要顺序读取该文件，记录如何存放处理时间最短？<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/os11.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 银行家算法 </tag>
            
            <tag> PV操作 </tag>
            
            <tag> 调度算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础语法（一）</title>
      <link href="/2019/06/26/java-ji-chu-yu-fa-yi/"/>
      <url>/2019/06/26/java-ji-chu-yu-fa-yi/</url>
      
        <content type="html"><![CDATA[<h3 id="1-方法重载（-overlord-）"><a href="#1-方法重载（-overlord-）" class="headerlink" title="1.方法重载（ overlord ）"></a>1.方法重载（ overlord ）</h3><h4 id="1-1为什么使用方法重载"><a href="#1-1为什么使用方法重载" class="headerlink" title="1.1为什么使用方法重载"></a>1.1为什么使用方法重载</h4><p>对于功能类似的方法来说，因为参数列表不一样，却需要记住那么多不同的方法名称过于麻烦。</p><h4 id="1-2方法重载概念"><a href="#1-2方法重载概念" class="headerlink" title="1.2方法重载概念"></a>1.2方法重载概念</h4><p>方法重载是指多个方法名称一样但参数列表不一样。只要记住一个方法名称，就能实现类似的多个功能。</p><h3 id="2-数组（array）"><a href="#2-数组（array）" class="headerlink" title="2.数组（array）"></a>2.数组（array）</h3><h4 id="2-1数组概念"><a href="#2-1数组概念" class="headerlink" title="2.1数组概念"></a>2.1数组概念</h4><p>数组是一种容器，可以同时存放多个数据值。</p><h4 id="2-2数组特点"><a href="#2-2数组特点" class="headerlink" title="2.2数组特点"></a>2.2数组特点</h4><p>1.数组是一种引用数据类型（除了八大基本数据类型都是引用类型）。<br>2.数组当中的多个数据，类型必须统一。<br>3.数组的长度在程序运行期间不可改变。<br>4.数组动态初始化时会有一个默认值。</p><h4 id="2-3内存"><a href="#2-3内存" class="headerlink" title="2.3内存"></a>2.3内存</h4><p>java的内存需要划分成五个部分<br>区域名称 | 作用<br>—|—<br>栈（stack） |存放的都是方法中的局部变量。方法的运行一定要在栈当中。<br>堆（Heap） | 凡是new出来的东西，都在堆当中。<br>方法区（Method Area） | 存储.class相关信息，包含方法的信息。<br>本地方法栈（native method stack） | JVM使用操作系统相关，与我们无关。<br>寄存器（Register） | 与cpu相关。性能非常高。 </p><p><strong>栈（stack）</strong>：存放的都是方法中的局部变量。方法的运行一定要在栈当中。<br>    局部变量：方法的参数，或者是方法｛｝内部的变量。<br>    作用域：一旦超出作用域，立刻从栈内存当中消失。<br><strong>堆（Heap）</strong>：凡是new出来的东西，都在堆当中。<br>    堆内存里面的东西都有一个地址值：16进制。<br>    堆里面的数据都有默认值。<br><strong>方法区（Method Area）</strong>：存储.class相关信息，包含方法的信息。<br><strong>本地方法栈（native method stack）</strong>：JVM使用操作系统相关，与我们无关。<br><strong>寄存器（Register）</strong>：与cpu相关。性能非常高。<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/1JAVA02.png" alt></p><h4 id="2-4数组的空指针异常"><a href="#2-4数组的空指针异常" class="headerlink" title="2.4数组的空指针异常"></a>2.4数组的空指针异常</h4><p>所有的引用类型变量，都可以赋值为一个null值。但代表期中什么都没有。<br>数组必须进行new初始化才能使用其中的元素。<br>如果只是赋值了一个null，没有进行new创建，那么将会发生空指针异常 NullPointerException</p><h3 id="3-JVM-JRE-JDK"><a href="#3-JVM-JRE-JDK" class="headerlink" title="3.JVM JRE JDK"></a>3.JVM JRE JDK</h3><p><strong>JVM（Java Virtual Machine ）</strong>：Java虚拟机，简称JVM，是运行所有Java程序的假想计算机，是Java程序的 运行环境，是Java 最具吸引力的特性之一。我们编写的Java代码，都运行在JVM上。跨平台。<br><strong>JRE  (Java Runtime Environment)</strong> ：是Java程序的运行时环境，包含JVM和运行时所需要的核心类库。<br><strong>JDK  (Java Development Kit)</strong>：是Java程序开发工具包，包含JRE和开发工具。</p><h3 id="4-跳出循环"><a href="#4-跳出循环" class="headerlink" title="4.跳出循环"></a>4.跳出循环</h3><p><strong>break</strong>：终止switch语句或者是循环。<br><strong>continue</strong>    ：结束本次循环，继续下一次循环。   </p><h3 id="5-数据类型"><a href="#5-数据类型" class="headerlink" title="5.数据类型"></a>5.数据类型</h3><p><strong>基本数据类型</strong>：字节型，整型，短整型，长整型，单精度浮点型，双精度浮点型，字符型，布尔型。<br><strong>引用数据类型</strong>：类，数组，接口。<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/1JAVA01.png" alt></p><h3 id="6-面向对象"><a href="#6-面向对象" class="headerlink" title="6.面向对象"></a>6.面向对象</h3><table><thead><tr><th>名称</th><th>概念</th></tr></thead><tbody><tr><td>面向过程</td><td>当需要实现某项功能时，每个具体的步骤都需要亲力亲为。</td></tr><tr><td>面向对象（偷懒）</td><td>当需要实现某项功能，不关心具体步骤，找一个能实现该功能的人，来帮我做事，</td></tr><tr><td>#### 6.1类和对象</td><td></td></tr><tr><td><strong>类</strong>：是一组相关属性和行为的结合。可以看成是一类事物的模版，使用事物的属性特征和行为特征来描述该类事物。</td><td></td></tr><tr><td>属性：就是该事物的状态信息。</td><td></td></tr><tr><td>行为：就是该事物能够做什么。</td><td></td></tr><tr><td><strong>对象</strong>：是一类事物的具体体现。对象是类的一个实例，必然具备该类事物的属性和行为。</td><td></td></tr><tr><td><strong>类和对象的关系</strong>：类是对一类事物的描述，是抽象的。 对象是一类事物的实例，是具体的。 类是对象的模板，对象是类的实体。</td><td></td></tr></tbody></table><h4 id="6-2对象的内存图"><a href="#6-2对象的内存图" class="headerlink" title="6.2对象的内存图"></a>6.2对象的内存图</h4><p><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/1JAVA03.png" alt></p><h4 id="6-3成员变量和局部变量"><a href="#6-3成员变量和局部变量" class="headerlink" title="6.3成员变量和局部变量"></a>6.3成员变量和局部变量</h4><h5 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h5><p>局部变量：只有方法当中才可以使用，出了方法就不能用了。<br>成员变量：在类当中整个类都可以通用。         </p><h5 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h5><p>局部变量：没有默认值。<br>成员变量：会有默认值。         </p><h5 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h5><p>局部变量：在方法内部。<br>成员变量：在方法外部，直接写在类当中。</p><h5 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h5><p>方法的参数是局部变量<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/1JAVA04.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 方法重载 </tag>
            
            <tag> 数组 </tag>
            
            <tag> java内存 </tag>
            
            <tag> JVM JRE JDK </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AdminLTE的基本使用</title>
      <link href="/2019/06/10/adminlte-de-ji-ben-shi-yong/"/>
      <url>/2019/06/10/adminlte-de-ji-ben-shi-yong/</url>
      
        <content type="html"><![CDATA[<h2 id="AdminLTE-基本使用"><a href="#AdminLTE-基本使用" class="headerlink" title="AdminLTE 基本使用"></a>AdminLTE 基本使用</h2><h3 id="1-AdminLTE简介"><a href="#1-AdminLTE简介" class="headerlink" title="1.AdminLTE简介"></a>1.AdminLTE简介</h3><p>AdminLTE是一款建立在bootstrap和jquery之上的开源的模板主题工具。<br><img src="https://camo.githubusercontent.com/e3bbc646d6ff473da2dd6cede2c968846a6982a6/68747470733a2f2f61646d696e6c74652e696f2f41646d696e4c5445322e706e67" alt="image"></p><h3 id="2-AdminLTE下载"><a href="#2-AdminLTE下载" class="headerlink" title="2.AdminLTE下载"></a>2.AdminLTE下载</h3><p>英文版下载地址：<a href="https://github.com/almasaeed2010/AdminLTE" target="_blank" rel="noopener">https://github.com/almasaeed2010/AdminLTE</a><br>中文版下载地址：<a href="https://github.com/itheima2017/adminlte2-itheima" target="_blank" rel="noopener">https://github.com/itheima2017/adminlte2-itheima</a></p><h3 id="3-AdminLTE结构介绍"><a href="#3-AdminLTE结构介绍" class="headerlink" title="3.AdminLTE结构介绍"></a>3.AdminLTE结构介绍</h3><p>AdminLTE依赖于两个框架Bootstrap3与JQuery1.11   </p><p><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/AdminLTE03.png" alt><br>在目录结构中assets、modules、pages、 plugins都是前端开发时所使用到的，最终发布的就是release。所以对于我们使用中文版来说，我们只需要关注release目录下的结构就可以。    </p><h3 id="4-布局皮肤"><a href="#4-布局皮肤" class="headerlink" title="4.布局皮肤"></a>4.布局皮肤</h3><p><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/AdminLTE02.png" alt></p><h4 id="4-1布局"><a href="#4-1布局" class="headerlink" title="4.1布局"></a>4.1布局</h4><p>.wrapper包住了body下的所有代码<br>.main-header里是网站的logo和导航栏的代码<br>.main-sidebar里是用户面板和侧边栏菜单的代码<br>.content-wrapper里是页面的页面和内容区域的代码 .main-footer里是页脚的代码<br>.control-sidebar里是页面右侧侧边栏区域的代码<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/AdminLTE06.png" alt></p><h4 id="4-2布局选项"><a href="#4-2布局选项" class="headerlink" title="4.2布局选项"></a>4.2布局选项</h4><p>fixed：固定<br>layout-boxed：盒子布局<br>ayout-top-nav：顶部隐藏<br>sidebar-collapse：侧边栏隐藏<br>sidebar-mini：侧边栏隐藏时有小图标      </p><h4 id="4-3皮肤"><a href="#4-3皮肤" class="headerlink" title="4.3皮肤"></a>4.3皮肤</h4><p>skin-blue：蓝色<br>skin-black：黑色<br>skin-purple：紫色<br>skin-yellow：黄色<br>skin-red：红色<br>skin-green：绿色<br>以上项我们可以查看start.html页面中查看。    </p><hr><h2 id="在SSM中的使用"><a href="#在SSM中的使用" class="headerlink" title="在SSM中的使用"></a>在SSM中的使用</h2><h3 id="1-导入到HBuilder"><a href="#1-导入到HBuilder" class="headerlink" title="1.导入到HBuilder"></a>1.导入到HBuilder</h3><p><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/AdminLTE01.png" alt></p><h3 id="2-在page目录下选择需要的页面"><a href="#2-在page目录下选择需要的页面" class="headerlink" title="2.在page目录下选择需要的页面"></a>2.在page目录下选择需要的页面</h3><p><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/AdminLTE04.png" alt></p><h3 id="3-对页面进行个性化修改"><a href="#3-对页面进行个性化修改" class="headerlink" title="3.对页面进行个性化修改"></a>3.对页面进行个性化修改</h3><p><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/AdminLTE05.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 主题模版 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AdminLTE </tag>
            
            <tag> bootstrap </tag>
            
            <tag> 主题模版 </tag>
            
            <tag> 后台模版 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SVN入门</title>
      <link href="/2019/06/09/svn-ru-men/"/>
      <url>/2019/06/09/svn-ru-men/</url>
      
        <content type="html"><![CDATA[<h2 id="1-SVN介绍"><a href="#1-SVN介绍" class="headerlink" title="1.SVN介绍"></a>1.SVN介绍</h2><p>SVN是Subversion的简称，是一个自由开源的版本控制系统。<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/SVN38.png" alt></p><h4 id="1-1操作解释"><a href="#1-1操作解释" class="headerlink" title="1.1操作解释"></a>1.1操作解释</h4><p>checkout：把整个项目代码下载到本地<br>update：将本地的源码更新至服务器的最新版本<br>commit：将本地源码更新内容提交到服务器  </p><h4 id="1-2避免干扰"><a href="#1-2避免干扰" class="headerlink" title="1.2避免干扰"></a>1.2避免干扰</h4><h5 id="1-2-1复制-修改-合并方案-Subversion默认的模式"><a href="#1-2-1复制-修改-合并方案-Subversion默认的模式" class="headerlink" title="1.2.1复制-修改-合并方案(Subversion默认的模式)"></a>1.2.1复制-修改-合并方案(Subversion默认的模式)</h5><p>每一个用户读取库在本地建立私人副本，在本地工作修改，最终合并成为最终版本，需要人工去整合判断正误。</p><h5 id="1-2-2锁定-修改-解锁方案"><a href="#1-2-2锁定-修改-解锁方案" class="headerlink" title="1.2.2锁定-修改-解锁方案"></a>1.2.2锁定-修改-解锁方案</h5><p>在这样的模型里，在一个时间段里配置库的一个文件只允许被一个人修改。 此模式不适合软件开发这种工作。 </p><h4 id="1-3安装位置"><a href="#1-3安装位置" class="headerlink" title="1.3安装位置"></a>1.3安装位置</h4><p>Subversion支持Linux和Windows，更多是安装在Linux下。         </p><h4 id="1-4运行方式"><a href="#1-4运行方式" class="headerlink" title="1.4运行方式"></a>1.4运行方式</h4><p>独立服务器和借助apache运行。</p><h4 id="1-5存储方式"><a href="#1-5存储方式" class="headerlink" title="1.5存储方式"></a>1.5存储方式</h4><p>BDB与FSFS<br>BDB一种事务安全型表类型和FSFS一种不需要数据库的存储系统。<br>因为BDB方式在服务器中断时，有可能锁住数据，所以还是FSFS方式更安全一点。</p><h2 id="2-SVN使用"><a href="#2-SVN使用" class="headerlink" title="2 SVN使用"></a>2 SVN使用</h2><p>window下svn服务器VisualSVN<br>客户端工具TortoiseSVN<br>idea svn插件</p><h3 id="2-1-服务器端VisualSVN安装与配置"><a href="#2-1-服务器端VisualSVN安装与配置" class="headerlink" title="2.1 服务器端VisualSVN安装与配置"></a>2.1 服务器端VisualSVN安装与配置</h3><h4 id="2-1-1官网下载visualSVN"><a href="#2-1-1官网下载visualSVN" class="headerlink" title="2.1.1官网下载visualSVN"></a>2.1.1官网下载visualSVN</h4><p><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/SVN01.png" alt></p><h4 id="2-1-2安装visualSVN"><a href="#2-1-2安装visualSVN" class="headerlink" title="2.1.2安装visualSVN"></a>2.1.2安装visualSVN</h4><p><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/SVN02.png" alt><br>location：安装位置<br>Repositories：仓库位置<br>存储方式使用FSFS<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/SVN03.png" alt></p><h4 id="2-1-3visualSVN使用"><a href="#2-1-3visualSVN使用" class="headerlink" title="2.1.3visualSVN使用"></a>2.1.3visualSVN使用</h4><p>创建组 创建用户<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/SVN04.png" alt><br>分配权限 创建仓库 复制仓库的URL输入浏览器中成功访问<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/SVN05.png" alt><br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/SVN06.png" alt></p><h3 id="2-2-客户端TortoiseSVN安装与配置"><a href="#2-2-客户端TortoiseSVN安装与配置" class="headerlink" title="2.2 客户端TortoiseSVN安装与配置"></a>2.2 客户端TortoiseSVN安装与配置</h3><p>TortoiseSVN是一个基于windows系统的svn客户端图形化界面</p><h4 id="2-2-1-TortoiseSVN的下载与安装"><a href="#2-2-1-TortoiseSVN的下载与安装" class="headerlink" title="2.2.1 TortoiseSVN的下载与安装"></a>2.2.1 TortoiseSVN的下载与安装</h4><p><a href="https://tortoisesvn.net/downloads.html" target="_blank" rel="noopener">https://tortoisesvn.net/downloads.html</a> 官网下载<br>安装注意 选择第二个选项 要不然没有svn.exe文件<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/SVN39.png" alt>    </p><h4 id="2-2-2-TortoiseSVN的使用"><a href="#2-2-2-TortoiseSVN的使用" class="headerlink" title="2.2.2 TortoiseSVN的使用"></a>2.2.2 TortoiseSVN的使用</h4><p>新建文件夹 右键就会看到tortoiseSVN 点击Repo-browser浏览仓库<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/SVN07.png" alt><br>输入认证信息赋予文件夹权限<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/SVN08.png" alt><br>右键setting 清理认证信息<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/SVN09.png" alt></p><h4 id="2-2-3-TortoiseSVN的操作"><a href="#2-2-3-TortoiseSVN的操作" class="headerlink" title="2.2.3 TortoiseSVN的操作"></a>2.2.3 TortoiseSVN的操作</h4><p>通过checkout从仓库下载文件<br>新建文件 右键add 然后commit message内填写修改信息</p><p><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/SVN10.png" alt><br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/SVN11.png" alt>       </p><p><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/SVN12.png" alt><br>update 更新服务器<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/SVN13.png" alt><br>show log查看历史版本<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/SVN14.png" alt></p><h4 id="2-2-4-导入与导出"><a href="#2-2-4-导入与导出" class="headerlink" title="2.2.4 导入与导出"></a>2.2.4 导入与导出</h4><p>Import将本地资源导入到svn服务器<br>Export导出项目，和checkout的区别,它不存在.svn隐藏文件<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/SVN16.png" alt></p><h4 id="2-2-5-冲突问题"><a href="#2-2-5-冲突问题" class="headerlink" title="2.2.5 冲突问题"></a>2.2.5 冲突问题</h4><p>遇到冲突 Edit confilcts解决冲突<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/SVN20.png" alt></p><h2 id="3-IDEA中使用TortoiseSVN"><a href="#3-IDEA中使用TortoiseSVN" class="headerlink" title="3.IDEA中使用TortoiseSVN"></a>3.IDEA中使用TortoiseSVN</h2><h3 id="3-1-setting中配置svn"><a href="#3-1-setting中配置svn" class="headerlink" title="3.1 setting中配置svn"></a>3.1 setting中配置svn</h3><p><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/SVN21.png" alt></p><h3 id="3-2-svn在idea中的基本操作"><a href="#3-2-svn在idea中的基本操作" class="headerlink" title="3.2 svn在idea中的基本操作"></a>3.2 svn在idea中的基本操作</h3><h4 id="3-2-1-将项目checkout"><a href="#3-2-1-将项目checkout" class="headerlink" title="3.2.1 将项目checkout"></a>3.2.1 将项目checkout</h4><p><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/SVN22.png" alt></p><h4 id="3-2-2-按钮作用-update-commit-历史-返回版本"><a href="#3-2-2-按钮作用-update-commit-历史-返回版本" class="headerlink" title="3.2.2 按钮作用 update commit 历史 返回版本"></a>3.2.2 按钮作用 update commit 历史 返回版本</h4><p><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/SVN23.png" alt>    </p><h4 id="3-2-3-将项目提交到SVN"><a href="#3-2-3-将项目提交到SVN" class="headerlink" title="3.2.3 将项目提交到SVN"></a>3.2.3 将项目提交到SVN</h4><p><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/SVN24.png" alt></p><h4 id="3-2-4-忽略设置"><a href="#3-2-4-忽略设置" class="headerlink" title="3.2.4 忽略设置"></a>3.2.4 忽略设置</h4><p><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/SVN30.png" alt>    </p><h4 id="3-2-5-冲突解决"><a href="#3-2-5-冲突解决" class="headerlink" title="3.2.5 冲突解决"></a>3.2.5 冲突解决</h4><p><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/SVN31.png" alt><br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/SVN32.png" alt></p><h3 id="3-3-项目模版"><a href="#3-3-项目模版" class="headerlink" title="3.3 项目模版"></a>3.3 项目模版</h3><h4 id="3-3-1-建立模版项目"><a href="#3-3-1-建立模版项目" class="headerlink" title="3.3.1 建立模版项目"></a>3.3.1 建立模版项目</h4><p>branches：分支项目<br>tags：分支版本（一般设为只读）<br>trunk：项目主干<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/SVN34.png" alt>      </p><h4 id="3-3-2-创建分支"><a href="#3-3-2-创建分支" class="headerlink" title="3.3.2 创建分支"></a>3.3.2 创建分支</h4><p><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/SVN35.png" alt></p><h4 id="3-3-3-主干分支合并"><a href="#3-3-3-主干分支合并" class="headerlink" title="3.3.3 主干分支合并"></a>3.3.3 主干分支合并</h4><p><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/SVN37.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 版本控制系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 版本控制系统 </tag>
            
            <tag> 自由 </tag>
            
            <tag> 开源 </tag>
            
            <tag> 项目管理 </tag>
            
            <tag> 多人开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git搭建与基本操作</title>
      <link href="/2019/06/07/git-da-jian-yu-ji-ben-cao-zuo/"/>
      <url>/2019/06/07/git-da-jian-yu-ji-ben-cao-zuo/</url>
      
        <content type="html"><![CDATA[<h2 id="Git理论"><a href="#Git理论" class="headerlink" title="Git理论"></a>Git理论</h2><h3 id="1-1git的概述"><a href="#1-1git的概述" class="headerlink" title="1,1git的概述"></a>1,1git的概述</h3><p>git是一个开源的分布式版本控制系统，可以借助github托管项目代码，进行团队开发。</p><h3 id="1-2git网址"><a href="#1-2git网址" class="headerlink" title="1.2git网址"></a>1.2git网址</h3><p>国内码云<br>国外github</p><h3 id="1-3-Git原理图"><a href="#1-3-Git原理图" class="headerlink" title="1.3 Git原理图"></a>1.3 Git原理图</h3><p><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/git18.png" alt></p><h2 id="Git实战"><a href="#Git实战" class="headerlink" title="Git实战"></a>Git实战</h2><p>使用前要安装git，并配置环境变量。</p><h3 id="2-1工作时开发的注意事项"><a href="#2-1工作时开发的注意事项" class="headerlink" title="2.1工作时开发的注意事项"></a>2.1工作时开发的注意事项</h3><p>1.代码需要备份各个版本都要备份【1.0版本出现问题，不能在2.0版本上修复】<br>2.上班下载代码，下班上传代码。<br>3.解决工作中团队开发的代码冲突问题。</p><h3 id="2-2在idea中使用Git"><a href="#2-2在idea中使用Git" class="headerlink" title="2.2在idea中使用Git"></a>2.2在idea中使用Git</h3><h4 id="2-2-1配置git"><a href="#2-2-1配置git" class="headerlink" title="2.2.1配置git"></a>2.2.1配置git</h4><p><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/git01.png" alt></p><h4 id="2-2-2搭建项目"><a href="#2-2-2搭建项目" class="headerlink" title="2.2.2搭建项目"></a>2.2.2搭建项目</h4><p>1.在码云上创建仓库<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/git02.png" alt><br>2.idea中新建项目，项目名要和码云上的一致。<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/git03.png" alt><br>3.将本地项目上传到码云上<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/git04.png" alt><br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/git05.png" alt><br>4.将本地项目删除通过码云上的ssh克隆一个项目到本地<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/git06.png" alt></p><h4 id="2-2-3项目上传"><a href="#2-2-3项目上传" class="headerlink" title="2.2.3项目上传"></a>2.2.3项目上传</h4><p>1.修改项目里的内容通过commit上传到本地的master<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/git07.png" alt><br>CommitMessage里面写修改的内容<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/git08.png" alt></p><hr><p>2.通过Push上传的git仓库<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/git09.png" alt><br>添加成功<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/git10.png" alt></p><h4 id="2-2-4版本操作管理"><a href="#2-2-4版本操作管理" class="headerlink" title="2.2.4版本操作管理"></a>2.2.4版本操作管理</h4><p>1.通过Branchers新建个版本分支<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/git11.png" alt></p><ol start="2"><li>1.0为新建的版本分支 master为主分支 check out是切换到该版本<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/git12.png" alt></li><li>登入码云看到分支添加成功<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/git13.png" alt></li><li>合并版本使用Merage<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/git14.png" alt><br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/git15.png" alt></li></ol><h4 id="2-2-5历史记录"><a href="#2-2-5历史记录" class="headerlink" title="2.2.5历史记录"></a>2.2.5历史记录</h4><p>1.使用Compare with 进行版本间的比较<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/git16.png" alt></p><p>2.历史记录按钮可看到项目或文件的历史修改信息<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/git19.png" alt><br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/git17.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 版本控制系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目管理 </tag>
            
            <tag> 多人开发 </tag>
            
            <tag> git </tag>
            
            <tag> 分布式版本控制系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建HEXO</title>
      <link href="/2019/06/05/da-jian-hexo/"/>
      <url>/2019/06/05/da-jian-hexo/</url>
      
        <content type="html"><![CDATA[<h2 id="认识-Hexo"><a href="#认识-Hexo" class="headerlink" title="认识 Hexo"></a>认识 Hexo</h2><p>hexo是一个快速，简洁高效的博客框架。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>1.node：用来生成静态页面的 到Node.js官网下载相应平台的最新版本。<br>2.git: 把本地的hexo内容提交到github上去。<br>3.github：用来做博客的远程创库、域名、服务器。</p><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>当Node.js和Git都安装好后就可以正式安装Hexo了，终端执行如下命令：</p><blockquote><p>$ sudo npm install -g hexo</p></blockquote><p>输入管理员密码即开始安装</p><blockquote><p>Hexo官网上的安装命令是$ npm install -g hexo-cli，安装时不要忘记前面加上sudo，否则会因为权限问题报错。<br>初始化</p></blockquote><p>终端cd到一个你选定的目录（比如创建一个blog文件，$cd blog），执行hexo init命令：</p><blockquote><p>$ hexo init</p></blockquote><p>在blog目录下，执行如下命令，安装npm：</p><blockquote><p>$ npm install</p></blockquote><p>执行如下命令，开启hexo服务器：</p><blockquote><p>$ hexo s</p></blockquote><p>此时，浏览器中打开网址<a href="http://localhost:4000，能看到如下页面：" target="_blank" rel="noopener">http://localhost:4000，能看到如下页面：</a><br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/hexo01.png" alt="hexo01"></p><h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><p>登录Github账号，新建仓库，名为用户名.github.io固定写法。<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/hexo02.png" alt="hexo02"></p><p>找到blog文件夹下的_config.yml文件找到最后一行修改为（更多yml部署查阅Hexo文档） </p><blockquote><p>deploy:<br>    type: git<br>    repository: <a href="https://github.com/edderqin/edderqin.github.io.git" target="_blank" rel="noopener">https://github.com/edderqin/edderqin.github.io.git</a><br>    branch: master</p></blockquote><p>注意：在配置所有的_config.yml文件时（包括theme中的），在所有的冒号:后边都要加一个空格，否则执行hexo命令会报错，切记 切记</p><p>在blog文件夹目录下执行生成静态页面命令：</p><blockquote><p>$ hexo generate        或者：hexo g</p></blockquote><p>再执行配置命令：</p><blockquote><p>$ hexo deploy            或者：hexo d</p></blockquote><p>注意：若执行命令hexo deploy仍然报错：无法连接git或找不到git，则执行如下命令来安装hexo-deployer-git：<br>$ npm install hexo-deployer-git –save<br>若你未关联Github，则执行hexo deploy命令时终端会提示你输入Github的用户名和密码<br>hexo deploy命令执行成功后，浏览器中打开网址<a href="http://edderqin.github.io（将edderqin换成你的用户名）能看到和打开http://localhost:4000时一样的页面。" target="_blank" rel="noopener">http://edderqin.github.io（将edderqin换成你的用户名）能看到和打开http://localhost:4000时一样的页面。</a>　</p><h2 id="添加ssh-key到Github"><a href="#添加ssh-key到Github" class="headerlink" title="添加ssh key到Github"></a>添加ssh key到Github</h2><p>1.1检查SSH keys是否存在Github<br>执行如下命令，检查SSH keys是否存在。如果有文件id_rsa.pub或id_dsa.pub，则直接进入步骤1.3将SSH key添加到Github中，否则进入下一步生成SSH key。</p><blockquote><p>$ ls -al ~/.ssh</p></blockquote><p>1.2.生成新的ssh key<br>执行如下命令生成public/private rsa key pair，注意将<a href="mailto:your_email@example.com" target="_blank" rel="noopener">your_email@example.com</a>换成你自己注册Github的邮箱地址。</p><blockquote><p>$ ssh-keygen -t rsa -C “<a href="mailto:your_email@example.com" target="_blank" rel="noopener">your_email@example.com</a>“默认会在相应路径下C盘用户目录下（~/.ssh/id_rsa.pub）生成id_rsa和id_rsa.pub两个文件</p></blockquote><p>1.3.将ssh key添加到Github中<br>Find前往文件夹~/.ssh/id_rsa.pub打开id_rsa.pub文件，里面的信息即为SSH key，将这些信息复制到Github的Add SSH key页面即可。<br>进入Github –&gt; Settings –&gt; SSH keys –&gt; add SSH key:<br>Title里任意添一个标题，将复制的内容粘贴到Key里，点击下方Add key绿色按钮即可。<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/hexo03.png" alt="hexo03"></p><h2 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h2><p>终端cd到blog文件夹下，执行如下命令新建文章：</p><blockquote><p>hexo new “postName”</p></blockquote><p>名为postName.md的文件会建在目录/blog/source/_posts下。<br>文章编辑完成后，终端cd到blog文件夹下，执行如下命令来发布: </p><blockquote><p>hexo g             //生成静态页面<br>hexo d            //将文章部署到Github</p></blockquote><h2 id="安装theme"><a href="#安装theme" class="headerlink" title="安装theme"></a>安装theme</h2><p>你可以到Hexo官网主题页去搜寻自己喜欢的theme。这里以hexo-theme-next为例<br>终端cd到 blog 目录下执行如下命令：</p><blockquote><p>$ git clone <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next</a> themes/next</p></blockquote><p>将blog目录下_config.yml里theme的名称landscape修改为next<br>终端cd到blog目录下执行如下命令(每次部署文章的步骤)：</p><blockquote><p>$ hexo clean           //清除缓存文件 (db.json) 和已生成的静态文件 (public)<br>$ hexo g             //生成缓存和静态文件<br>$ hexo d             //重新部署到服务器</p></blockquote><p>至于更改theme内容，比如名称，描述，头像等去修改blog/_config.yml文件和blog/themes/next/_config.yml文件中对应的属性名称即可，不要忘记冒号:后加空格。NexT 使用文档里有极详细的介绍。</p><h2 id="绑定个人域名"><a href="#绑定个人域名" class="headerlink" title="绑定个人域名"></a>绑定个人域名</h2><p>首先要有一个域名我的域名是在阿里云买的<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/hexo04.png" alt="hexo04"></p><p>审核通过后进行解析<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/hexo06.png" alt="hexo06"><br>添加三条解析 后两条固定为，192.30.252.153和192.30.252.154这两个IP地址为github的服务器地址 CNAME记录值填你的github博客网址<br>这些全部设置完成后，此时你并不能要申请的域名访问你的博客。接着你需要做的是在hexo根目录的source文件夹里创建CNAME文件，不带任何后缀，里面添加你的域名信息 如 edderblog.top<br><img src="https://raw.githubusercontent.com/edderqin/picflod/master/img/hexo07.png" alt="hexo07"><br>接下来输入域名即可访问项目</p><p>参考资料:<br><a href="https://www.cnblogs.com/penglei-it/p/hexo_domain_name.html" target="_blank" rel="noopener">https://www.cnblogs.com/penglei-it/p/hexo_domain_name.html</a> hexo域名配置<br><a href="https://www.cnblogs.com/MuYunyun/p/5927491.html" target="_blank" rel="noopener">https://www.cnblogs.com/MuYunyun/p/5927491.html</a> 建站参考<br><a href="https://www.cnblogs.com/fengxiongZz/p/7707219.html" target="_blank" rel="noopener">https://www.cnblogs.com/fengxiongZz/p/7707219.html</a> 建站详细资料<br><a href="https://easyhexo.com/https://easyhexo.com/" target="_blank" rel="noopener">https://easyhexo.com/https://easyhexo.com/</a> eazy hexo</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> git </tag>
            
            <tag> 搭建博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/06/04/hello-world/"/>
      <url>/2019/06/04/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
